[{"categories":["技术"],"content":"需求 iOS系统自带语音效果不佳，最近接触到Auzre TTS服务效果良好。想在读书软件香色闺阁中加入Auzre tts音色。\n方案 在服务端对Auzre tts服务进行封装，对外提供接口。\nAuzre tts 先注册Auzre账号，Azure AI services|语音服务中创建项目，获取秘钥和区域。 参考官方文档编写文本转语音相关代码。 密钥和区域写入环境变量中，在代码中读取。 音色列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import requests import json import configparser import os # URL地址 url = 'https://japanwest.tts.speech.microsoft.com/cognitiveservices/voices/list' # 定义headers headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4', 'Ocp-Apim-Subscription-Key':os.environ.get('SPEECH_KEY'), # 其他您需要的headers } # 发送GET请求，包含headers response = requests.get(url, headers=headers) # 检查请求是否成功 if response.status_code == 200: config = configparser.ConfigParser() config.read('config.ini') config['voice']={} # 输出返回的数据 data = json.loads(response.text) for voice in data: if voice['Locale'] == 'zh-CN' or voice['Locale'] == 'zh-TW': config['voice'][voice['DisplayName']] =voice['ShortName'] with open('config.ini', 'w',encoding='utf-8') as configfile: config.write(configfile) else: # 输出错误信息 print('Error:', response.status_code) 文本转语音 config.ini文件与下面代码放在同一目录下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import azure.cognitiveservices.speech as speechsdk import os import configparser class tts(): def __init__(self): self.config = configparser.ConfigParser() self.config.read('config.ini') def speak(self, voice_id,text): path = '/home/ubuntu/tts/output.wav' speech_config = speechsdk.SpeechConfig(subscription=os.environ.get('SPEECH_KEY'), region=\"japanwest\") file_config = speechsdk.audio.AudioOutputConfig(filename=path) speech_config.speech_synthesis_voice_name= self.config['voices'][voice_id] speech_synthesizer = speechsdk.SpeechSynthesizer(speech_config=speech_config, audio_config=file_config) speech_synthesis_result = speech_synthesizer.speak_text_async(text).get() return path,speech_synthesis_result if __name__ == \"__main__\": text_to_tts = tts() text_to_tts.speak(\"yunxia\",\"2019/03/02上午有1/2的概率下暴雨所以有600人選擇3:30p.m.再出門,支付$500或￥600可以獲得代金券\") 对外接口 基于fastapi编写对外服务接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from fastapi import FastAPI,Query from fastapi.responses import FileResponse from pydantic import BaseModel from speech_synthesis import tts import os import uvicorn # class TTSRequest(BaseModel): # voice_id: str # 假设voice_id是一个整数 # text: str # text是一个字符串 app = FastAPI() # @app.get(\"/tts/\") # async def handle_tts(request: TTSRequest): # text_to_speech = tts() # audio_file_path,speech_synthesis_result = text_to_speech.speak(request.voice_id, request.text) # if os.path.isfile(audio_file_path): # # 使用 FileResponse 返回文件内容 # return FileResponse(audio_file_path, filename=\"output.wav\", media_type=\"audio/wav\") # else: # print(\"audio_file_path: \" + audio_file_path) # print(speech_synthesis_result) # return {\"error\": \"File not found\"}, 404 @app.get(\"/tts/\") async def handle_tts(voice_id: str = Query(None, description=\"The ID of the voice to use\"), text: str = Query(None, description=\"The text to be synthesized\")): text_to_speech = tts() audio_file_path,speech_synthesis_result = text_to_speech.speak(voice_id, text) if os.path.isfile(audio_file_path): # 使用 FileResponse 返回文件内容 return FileResponse(audio_file_path, filename=\"output.wav\", media_type=\"audio/wav\") else: print(\"audio_file_path: \" + audio_file_path) print(speech_synthesis_result) return {\"error\": \"File not found\"}, 404 if __name__ == \"__main__\": uvicorn.run(app, host=\"0.0.0.0\", port=8000) 部署 服务器用的ubuntu，将上面python代码和config.ini放到/home/ubuntu/tts中 python执行代码提供服务 编写香色tts源 为了方便写源，可以从香色中导出一个语音源，使用下列代码转换成json格式。修改json中内容，然后再转换成xbs在香色中导入即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import xxtea import struct import os import json xxtea_key = bytes([0xe5, 0x87, 0xbc, 0xe8, 0xa4, 0x86, 0xe6, 0xbb, 0xbf, 0xe9, 0x87, 0x91, 0xe6, 0xba, 0xa1, 0xe5]) def xbs2json(buffer): try: out = xxtea.decrypt(buffer, xxtea_key,False, 0) except Exception as e: return None, str(e) n = len(buffer) n -= 4 m = struct.unpack('\u003cI', out[n:])[0] if m \u003c n - 3 or m \u003e n: return None, \"decode error\" n = m return out[:n], None def json2xbs(buffer): buffer_len = len(buffer) n = buffer_len // 4 if buffer_len % 4 != 0: n += 1 # Pad the buffer to the next multiple of 4 padding_length = n * 4 - buffer_len buffer_enc_len = b'\\x00' * padding_length # Append the original buffer length as a little-endian uint32 buffer_enc_len += struct.pack('\u003cI', buffer_len) # Combine the original buffer with the padding and length buffer = buffer + buffer_enc_len try: # Encrypt the buffer using XXTEA out = xxtea.encrypt(buffer, xxtea_key,False, 0) return out, None except Exception as e: return None, str(e) def load_file(filepath): if os.path.exists(filepath): with open(filepath, 'rb') as file: return file.read(),None else: return None, f\"File {filepath} does not exist.\" def xbs_to_json(input,output): data, error = load_file(input) if error: print(error) exit(1) encode_data,error = xbs2json(data) if error: print(error) exit(1) # 打开文件以二进制模式写入 with open(output, 'w', encoding='utf-8') as f: json_data = json.loads(encode_data.decode('utf-8')) json.dump(json_data, f, ensure_ascii=False, indent=4) def json_to_xbs(input,output): data, error = load_file(input) if error: print(error) exit(1) decode_data,error = json2xbs(data) if error: print(error) exit(1) with open(output, 'wb') as f: f.write(decode_data) if __name__ == '__main__': xbs_to_json('D:\\\\workspace\\\\script\\\\xs\\\\test\\\\azure_tts.xbs' , 'D:\\\\workspace\\\\script\\\\xs\\\\test\\\\azure_tts1.json') json_to_xbs('D:\\\\workspace\\\\script\\\\xs\\\\test\\\\azure_tts1.json' , 'D:\\\\workspace\\\\script\\\\xs\\\\test\\\\azure_tts1.xbs') 修改点为requestInfo中url调整为自己服务的域名，body只保留voice_id参数。requestFilters调整为Azure TTS音色信息，与上面config中id对应。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 { \"语音设置-azure\": { \"chapterContent\": { \"actionID\": \"chapterContent\", \"parserID\": \"DOM\" }, \"enable\": 1, \"shupingList\": { \"actionID\": \"shupingList\", \"parserID\": \"DOM\" }, \"authorId\": \"\", \"bookDetail\": { \"actionID\": \"bookDetail\", \"parserID\": \"DOM\" }, \"bookWorld\": { \"azure\": { \"actionID\": \"bookWorld\", \"validConfig\": \"\", \"requestInfo\": \"@js:\\n\\nlet url=\\\"https://tts.xiaoshame1.pp.ua/tts/\\\";\\nlet body={\\n voice_id:params.filters.type,\\n};\\nlet _conf={\\n key:'text',\\n body:body,\\n headers:{},\\n post:false,\\n url:url\\n };\\n\\nparams.nativeTool.setCache(\\\"xsreader_voice_conf\\\",JSON.stringify(_conf));\\nreturn config.host\", \"bookName\": \"@js:\\nlet regt=`\\\\n\\\\s*(.*?)::${params.filters.type}\\\\n`\\nlet reg=new RegExp(regt)\\nlet name=config.moreKeys.requestFilters.match(reg)[1]\\nreturn \\\"当前语音：\\\"+name\", \"detailUrl\": \"@js:\\nreturn config.host\", \"host\": \"http://captive.apple.com\", \"_sIndex\": 7, \"list\": \"//title\", \"responseFormatType\": \"html\", \"parserID\": \"DOM\", \"moreKeys\": { \"pageSize\": 30, \"requestFilters\": \"type\\n晓晓::Xiaoxiao\\n云希::Yunxi\\n云健::Yunjian\\n晓伊::Xiaoyi\\n云扬::Yunyang\\n晓辰::Xiaochen\\n晓涵::Xiaohan\\n晓梦::Xiaomeng\\n晓墨::Xiaomo\\n晓秋::Xiaoqiu\\n晓睿::Xiaorui\\n晓双::Xiaoshuang\\n晓晓 方言::Xiaoxiao Dialects\\n晓晓 多语言::Xiaoxiao Multilingual\\n晓颜::Xiaoyan\\n晓悠::Xiaoyou\\n晓甄::Xiaozhen\\n云枫::Yunfeng\\n云皓::Yunhao\\n云夏::Yunxia\\n云野::Yunye\\n云泽::Yunze\\n晓萱::Xiaoxuan\\n曉臻::HsiaoChen\\n雲哲::YunJhe\\n曉雨::HsiaoYu\" } } }, \"shudanList\": {}, \"sourceType\": \"text\", \"relatedWord\": { \"actionID\": \"relatedWord\", \"parserID\": \"DOM\" }, \"weight\": \"9999\", \"sourceName\": \"语音设置-azure\", \"sourceUrl\": \"http://captive.apple.com\", \"miniAppVersion\": \"2.53.2\", \"shudanDetail\": { \"actionID\": \"shudanDetail\", \"parserID\": \"DOM\" }, \"lastModifyTime\": \"1695541859.065246\", \"shupingHome\": { \"actionID\": \"shupingHome\", \"parserID\": \"DOM\" }, \"searchShudan\": { \"actionID\": \"searchShudan\", \"parserID\": \"DOM\" }, \"searchBook\": { \"actionID\": \"searchBook\", \"parserID\": \"DOM\" }, \"chapterList\": { \"actionID\": \"chapterList\", \"parserID\": \"DOM\" } } } 使用 发现中切换到导入的音色源，选择音色 文章点击朗读，发音中选择语音测试 总结 此方案同样可以封装阿里云和百度云的TTS服务，只需要增加想要云服务API调用代码。 代码比较简单，云API调用按照官方文档的步骤来，fastapi相关代码借助GPT完成。 查看他人源可以比较快熟悉香色源的编写规则，转换成json后调整效率更高。 ","description":"","tags":["tts","python"],"title":"使用微软TTS服务进行小说朗读","uri":"/posts/auzre_tts/"},{"categories":["生活"],"content":"结婚后生活趋向稳定，日常生活都围绕小孩展开。随着小孩年龄的增长，学区房也提上了议程。最终决定将老婆婚前房产置换为学区房。开始卖房买房的旅途。\n卖房 20年下半年就计划购买学区房，刚把房子挂到贝壳上，没过几天就有人要买，当时觉得卖便宜了，没有同意。后续因老婆工作变动，卖房计划就暂停了。\n转眼来到22年下半年，卖房计划又重新启动，计划23年底之前要卖掉，最终在24年1月成交。中间多次有买家报价，都低于我们预期价格，同时距离我们认为的截止时间还有很长时间，最终都没有成交。买家出价一次比一次低，我们也越发不甘心。\n没想到23年10月小区价格出现踩踏，最终成交价相比20年跌幅接近40%。时代的一粒灰，落在个人头上，就是一座山。所幸房子购买较早，基本没有亏损本金，利息就不提了。\n整个卖房过程就像一个赌徒，充满了不甘心和无可奈何。也像极了炒股，最终割肉出局。\n买房 所幸我们是置换，我们购买的学区房相对高点跌幅也高达30%多。\n根据小学和初中对口信息先圈选了小区，最终只有2个小区符合要求。一个已有20多年历史还没有电梯，另外一个也快20年。考虑到购房后居住的时间，重点考察新一点的小区。 23年把该小区在售意向户型房源全部实地考察了一遍，等房子尾款到手后，4月完成了买房所有流程。\n买房过程中非常担心后续继续下跌，已做好后期房子无法出手的准备。学区对口真是把人拿捏的死死的，完全无法挣脱，无可奈何。\n","description":"","tags":["购房"],"title":"购房","uri":"/posts/house/"},{"categories":["生活"],"content":"居家休养\n清明时节雨纷纷，武汉的天气完美印证这句诗。小朋友感冒刚痊愈，为了让孩子安心休养，我们选择在家度过这段假期。\n‍ 时隔多年，再次下厨\n多年没有下厨，为了保障中午有饭吃，第一天做几道简单的菜：丝瓜炒蛋、土豆丝炒肉、时蔬、卤猪蹄(买的冷记)，全部吃完，获得了老婆孩子的认可自信心膨胀，第二天做了一道硬菜就翻车了。\n玩轮滑，抓娃娃\n整个假期带娃上了轮滑、英语和跳舞课，上课结束后玩了抓娃娃和游乐场。抓娃娃店的生意非常火爆，一个机器投入10到20个币后，机器的爪子明显要紧很多一定能抓一个娃娃，这个点子真是抓住人性，小朋友抓到娃娃后非常兴奋，家长也愿意花钱，最后还可以凭抓的娃娃兑换礼物。同样的生意，改变下经营策略，就会散发不同的生命力。\n寻找桑叶\n放假前，妻子从公司带回了一些蚕宝宝。为了给蚕宝宝找食物，一大早就出发去了森林公园。在公园里兜兜转转，还真找到了几棵桑树。孩子亲手摘了桑叶，同时告诉她桑叶断裂时会爆浆，小孩子的学习能力确实很强，隔天就用到这个知识。桑葚还是青的，和小朋友约定等桑葚成熟后，再来一起摘桑葚。\n陪伴值班\n第三天，老婆公司安排下午值班。上午我们先去了龙阳湖公园。公园有儿童钓虾区，两大一小49.9，耗时1小时只钓上来6只虾。钓完虾后就出发前往老婆公司，娃在躺椅上睡觉，我帮老婆整理电脑，一天非常的轻松。\n‍‍‍ 游戏相伴\n晚上基本上是游戏时间，我和小朋友一起玩“耀西的手工世界”，switch真是操作简单，现在小朋友已经可以熟练操控耀西，估计下周就可以通关这个游戏，可以准备安排下一个游戏了。\n结语\n平时因工作没有时间陪伴老婆和孩子，短暂的清明假期，虽然没有外出旅行，只要全家人在一起做一些事情就足以，珍惜当下。\n","description":"","tags":["陪伴"],"title":"与家人共度美好清明假期","uri":"/posts/qingming/"},{"categories":["财商"],"content":"《邻家的百万富翁》是今年阅读计划的第一本书，整体阅读70%。书中的统计数据和案例，揭开了富人生活的一角，有两个案例给我留下了深刻的印象。\n富人对汽车的态度，颠覆了我以往的认知。他们不盲目追求新车，而是选择更具性价比的二手车，大部分富人在一辆汽车上的开支不超过3万元，并使用十年以上。在一期博客节目中，听张云帆说他有个原则，不购买超过资产12%的物品。回想自己日常的消费观，不免汗颜，道理不在多而在应用。如何控制欲望调整消费观，还需不断的努力。\n富人的收入来源多元，工资收入仅占总资产的3%左右，而大部分收入来自于投资理财，且税收支出占比极低。对比目前家庭的收入结构和税收负担，与富人存在明显差距。如何学习投资知识，通过投资增加收入，是值深思的问题。学校教育侧重于生存技能的传授，却往往忽略了财商教育，如何提高下一代的财商知识，避免悲剧发生在下一代，也是一个问题。\n","description":"","tags":["读书笔记"],"title":"《邻家的百万富翁》读后感","uri":"/posts/the_millionaire_next_door/"},{"categories":["技术"],"content":"背景 平时手机不方便在线观看电影，最近看到一个方案可以解决我的问题，手动部署下。\n整体方案：\n快捷指令发送RPC请求到aria2服务器实现离线下载 filebrowser实现下载文件管理，通过filebrowser分享功能获取分享链接 手机上使用VLC通过分享链接观看视频 准备工作 1台服务器，系统用的ubuntu 22.04 1个域名,配置好dns 我使用cloudflare管理域名，配置好dns后在SSL/TLS选择中选择Full模式 安装docker和docker-compose sudo apt-get update sudo apt install docker.io docker-compose 安装caddy2 sudo apt install -y debian-keyring debian-archive-keyring apt-transport-https curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | sudo gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | sudo tee /etc/apt/sources.list.d/caddy-stable.list sudo apt update sudo apt install caddy sudo systemctl enable --now caddy caddy2官方安装文档 安装filebrowser 基于开源项目filebrowser-docker采用docker-compose.yml安装，配置如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 version: \"3\" services: filebrowser: image: hurlenko/filebrowser ports: - 8080:8080 volumes: - ./data:/data - ./config:/config environment: - FB_BASEURL=/filebrowser restart: always 在docker-compose.yml 同级目录创建data，config 目录 docker-compose up -d运行 配置域名，编辑/etc/caddy/Caddyfile文件，添加如下内容后，systemctl restart caddy重启caddy 1 2 3 file.你的域名 { reverse_proxy 127.0.0.1:8080 } 在网页中访问file.你的域名 即可访问，登录密码为admin/admin 自行修改密码 到此filebrower安装完成，接下来安装aria2和ariang\n安装aria2和ariang 基于开源方案Aria2-Pro-Docker采用docker-compose.yml安装, 配置文件如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 version: \"3.8\" services: Aria2-Pro: container_name: aria2-pro image: p3terx/aria2-pro environment: - PUID=65534 - PGID=65534 - UMASK_SET=022 - RPC_PORT=6800 - LISTEN_PORT=6888 - DISK_CACHE=64M - IPV6_MODE=false - UPDATE_TRACKERS=true - CUSTOM_TRACKER_URL= - TZ=Asia/Shanghai - RPC_SECRET=设置你的KEY volumes: - ./aria2-config:/config - /home/ubuntu/filebrowser/data:/data/downloads ## 此处/home/ubuntu/filebrowser/data修改为你的filebrower绑定的data路径 # If you use host network mode, then no port mapping is required. # This is the easiest way to use IPv6 networks. # network_mode: host network_mode: bridge ports: - 6800:6800 - 6888:6888 - 6888:6888/udp restart: unless-stopped # Since Aria2 will continue to generate logs, limit the log size to 1M to prevent your hard disk from running out of space. logging: driver: json-file options: max-size: 1m # AriaNg is just a static web page, usually you only need to deploy on a single host. AriaNg: container_name: ariang image: p3terx/ariang command: --port 6880 --ipv6 # network_mode: host network_mode: bridge ports: - 6880:6880 restart: unless-stopped logging: driver: json-file options: max-size: 1m docker-compose up -d运行 配置域名，编辑/etc/caddy/Caddyfile文件，添加如下内容后，systemctl restart caddy重启caddy 1 2 3 4 5 6 aria2.你的域名 { reverse_proxy 127.0.0.1:6880 } rpc.你的域名 { reverse_proxy 127.0.0.1:6800 } 通过aria2.你的域名即可在网页中访问ariang 在AiraNg设置-RPC中修改配置 Aria2 RPC地址修改为：rpc.你的域名，端口改成443 Aria2 RPC 密钥修改为：docker-compose.yml中RPC_SECRET配置的值 到此aria2和ariang 安装完成。\n配置快捷指令 手机网页打开RPC 请求快捷指令安装指令 配置RPC请求域名和密钥 ","description":"","tags":["快捷指令","aria2"],"title":"苹果手机离线下载方案","uri":"/posts/ios_download/"},{"categories":["技术"],"content":"支持接入通义千问和星火认知大模型，本文主要介绍通义千问的接入方案。星火认知大模型接入方案类似，星火接入文档\n前期准备 github账号 vercel账号 微信公众号 nic.ua账号 阿里云账号 Telegram账号 cloudflare账号 一个外币卡 操作流程 注册域名 注册nic.ua账号，申请免费域名，注册需要绑定信用卡，验证扣费1乌克兰格里夫纳约0.19人民币 申请的免费域名需要激活，推荐使用Telegram进行激活，注意Telegram注册的账号与nic.ua注册的手机号一致 在cloudflare中添加新申请的域名，在nic.ua中修改NS服务器到cloudflare 参考：永久免费域名PP.UA最新注册指南 嫌麻烦，可以直接在阿里云/Godaddy等网站买个最便宜的域名 开通通义千问 注册阿里云账号，开通模型服务灵积服务 服务开通成功后，在左侧菜单找到管理中心-\u003eAPI-KEY管理，创建apiKey备用 vercel部署 注册github账号后，forkqw-wechat-vercel项目到自己仓库,感谢LuhangRui qw-wechat-vercel项目 注册vercel账号后，创建项目，选择Import Git Repository从github仓库导入。在Environment Variables选项卡，增加环境变量把下面的变量一项一项的加进去 序列 变量 说明 1 API_KEY=sk-xxxx 阿里云中创建的apikey 2 KEYWORD_REPLAY={\"千问\":\"大模型回答\"} 自定义关键词，咨询问题包含千问 才由大模型回答 3 API_MODEL=qwen-72b-chat 大模型类型 4 WX_TOKEN=53acb98d1dac49969b45797129f504f8 32位字符，后续公众号服务器配置会用到 5 SUBSCRIBE_REPLY=欢迎关注，我已经接入了阿里千问智能AI，咨询我问题请以千问开头，例如：千问，你好 关注自动回复 绑定域名 在cloudflare中对应域名下添加DNS解析，添加A记录将域名指向76.223.126.88。 待vercel部署完成后，点击ADD Domain，把你的域名填上去就好了，会自动加https。提示添加解析时选择只添加域名 参考：Vercel应用绑定自己的域名 访问https://你的域名/api/spark-wechat 页面输出failed，即为部署成功 访问https://你的域名 页面404，是因为项目里没有部署页面，所以访问会404 配置公众号 注册公众号，个人订阅号就行 后台管理页面上找到设置与开发-基本配置-服务器配置，点修改 服务器地址url：https://你的域名/api/spark-wechat TOKEN为第4步中使用的WX_TOKEN， EncodingAESKey随机生成(不用这一项) 选明文模式就好了，提交会提示token验证成功，然后点启用服务器配置。 公众号测试 ","description":"","tags":["大模型"],"title":"花2毛钱给微信公众号接入阿里云通义千问大模型","uri":"/posts/gzh_chat/"},{"categories":["生活"],"content":"\r文章更新后无法同步到公众号，如果您是在公众号阅读的本文，可以点击阅读原文查看更新后的内容。\n背景 昨天看到YUNYI BLOG，一直也想总结下自己日常生活和工作使用的软件，合适的软件能帮助我们提高效率，起到事半功倍的效果。下面是我常用的一些软件，推荐给大家。\n电脑软件（Windwos） 序号 名称 说明 1 Edge 浏览器 2 Google Chrome 浏览器 3 Microsoft Office Word, Excel, PowerPoint, Outlook 4 Hugo 博客静态站点生成器 5 7zip 解压缩工具 6 Totalcmd 文件管理工具 7 OneNote 在线笔记 8 Microsoft To Do to do 9 文件蜈蚣 磁链/BT下载工具 10 Internet Download Manager 日常下载工具 11 v2aryN 上网工具 12 Xshell7 SSH 13 VLC 视频播放 14 洛雪音乐助手 听歌软件 15 Beyond Compare 4 文本差异对比 16 Everything 本地文件搜索 17 pot 翻译+划词翻译 18 PixPin 截图+OCR 19 vscode 代码编写 20 SpaceSniffer 磁盘文件大小统计 21 PowerShell 命令行 22 yt-dlp youtube/B站视频下载 23 GPT4 编码助手 手机软件（iPhone） 序号 名称 说明 1 Edge 浏览器 2 高德地图 地图 3 图书 看书 4 香色闺阁 看小说 5 京东 购物 6 微信 聊天 7 支付宝 买基金 8 招商银行 银行 9 国家医保服务平台 医保 10 快捷指令 自动化 11 文件 文件管理 12 翻译 本地翻译 13 播客 听播客 14 Feedly RSS 阅读器 15 Shadowrocket 上网工具 16 Microsoft To Do 待办事项 17 youtube 看视频 18 Gmail 邮箱 19 Stream 抓包 20 VLC 本地视频播放 21 a-Shell 配合快捷指令 22 PikPak 网盘，离线下载 23 X 新闻 24 OneNote 在线笔记 25 Slay the Spire 杀戮尖塔 肉鸽卡牌 ","description":"","tags":["APP"],"title":"App Defaults","uri":"/posts/app_defaults/"},{"categories":["技术"],"content":"背景 在公众号发布过一个文章python批量获取最新博客，实现将一系列公众号最新发布的文章保存到本地方便阅读。实际使用过程中，发现在本地阅读非常不方便，导致使用几次后就放弃。平时我使用feedly订阅RSS阅读，所以想到能不能将这些内容使用feedly进行订阅方便阅读。\n解决思路 feedly订阅的是一个网站的rss.xml文件，所以只需构造一个rss.xml文件放到服务器,对应的文件支持通过http访问，即可在feedly进行订阅 使用服务器定时任务，定时更新最近发布的公众号文章信息到rss.xml文件 minio服务可以对外提供文件服务 具体操作 获取一个xml模板 我直接下载了博客网站的rss.xml文件 删除rss.xml文件中的文章信息 修改rss.xml文件中的title,description,link,href等信息 1 2 3 4 5 6 7 8 9 10 11 \u003c?xml version='1.0' encoding='UTF-8'?\u003e \u003crss xmlns:ns0=\"http://purl.org/rss/1.0/modules/content/\" version=\"2.0\"\u003e \u003cchannel\u003e \u003ctitle\u003e公众号综合\u003c/title\u003e \u003clink\u003ehttps://xiaoqian713.live/rss/rss.xml\u003c/link\u003e \u003cdescription\u003e公众号聚合\u003c/description\u003e \u003ccopyright\u003easong\u003c/copyright\u003e \u003cpubDate\u003eMon, 22 Jan 2024 16:28:02 \u003c/pubDate\u003e \u003clastBuildDate\u003eMon, 22 Jan 2024 16:28:02 \u003c/lastBuildDate\u003e \u003c/channel\u003e \u003c/rss\u003e 修改python代码 将本地保存文章调整为将获取到的RSS信息中的文章内容保存到xml中 使用docker部署了minio对象存储服务，用于存储rss.xml文件 将代码和rss.xml放到服务器中，配置python相关环境 测试代码确定运行无误，rss.xml可自行上传到minio中 在feedly中订阅对应的文件地址 大家想订阅这个rss,订阅地址为：https://xiaoqian713.live/rss/rss.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 import concurrent.futures import xml.etree.ElementTree as ET from datetime import datetime, timedelta import threading import requests import minio from bs4 import BeautifulSoup # 定义一个锁 lock = threading.Lock() def get_list_name_url(html): # 创建BeautifulSoup对象bito.ai soup = BeautifulSoup(html, 'html.parser') # 提取博客名称和RSS地址内容 name_list = [] url_list = [] paragraph = soup.find_all('div', class_='vp-doc _list_all') for parent in paragraph: span_a_content = parent.find_all(name='p') for a_content in span_a_content: name_list.append(a_content.find('a').text) url_list.append(a_content.find('a')['href']) return name_list, url_list def get_recent_article(url,channel,start_time,end_time): ## 获取对应XML信息 try: response = requests.get(url=url, headers={}) content_type = response.headers.get('Content-Type') # 检查是否有charset=utf-8 if 'charset=utf-8' in content_type: xml = response.text else: # 如果不是UTF-8，可以尝试手动转换编码 xml = response.content.decode('utf-8', errors='ignore') except requests.exceptions.SSLError as err: print('SSL Error. Adding custom certs to Certifi store...') # 加载XML文件,获取根元素 try: # 查找最新的文章 new_rss = ET.fromstring(xml) # new_root = new_rss.getroot() # # mew_channel = ET.SubElement(new_rss, 'channel') new_channel = new_rss.find('channel') if new_channel is None: return url + \" fail\" # 使用锁来同步访问 with lock: for item in new_channel.findall('item'): node = item.find('pubDate') if node is not None and node.text != \"\": # 将日期时间字符串转换为时间对象 if node.text.endswith(\"GMT\"): pubDate = datetime.strptime(node.text, \"%a, %d %b %Y %H:%M:%S %Z\").replace(tzinfo=None) else: pubDate = datetime.strptime(node.text, \"%a, %d %b %Y %H:%M:%S %z\").replace(tzinfo=None) ## 将内容写入文件中 if pubDate \u003e start_time and pubDate \u003c end_time: first_item = channel.find('item') if first_item is not None: channel.insert(list(channel).index(first_item), item) else: # 如果没有其他item元素，直接追加到channel元素 channel.append(item) return url + \" successe\" except ET.ParseError: return url + \" fail\" def get_blog_list(url,start_time,end_time): ## 获取对应网页html try: html = requests.get(url=url, headers='').text except requests.exceptions.SSLError as err: print('SSL Error. Adding custom certs to Certifi store...') ## 获取不同博客名和对应RSS订阅地址 name_list,url_list = get_list_name_url(html) # 创建或加载新的RSS文件树和根元素 rss = ET.parse(r'D:\\workspace\\script\\gzh_to_rss\\rss.xml') root = rss.getroot() channel = root.find('channel') last_build_date = channel.find('lastBuildDate') pubDate = channel.find('pubDate') if last_build_date is not None: last_build_date.text = end_time.strftime('%a, %d %b %Y %H:%M:%S %z') if pubDate is not None: pubDate.text = end_time.strftime('%a, %d %b %Y %H:%M:%S %z') # channel = ET.SubElement(rss, 'channel') # 提交任务给线程池，并获取Future对象 futures = [] # 创建线程池 executor = concurrent.futures.ThreadPoolExecutor() for i in range(len(url_list)): future = executor.submit(get_recent_article,url_list[i],channel,start_time,end_time) futures.append(future) # 获取任务的返回值 # results = [] for future in concurrent.futures.as_completed(futures): result = future.result() print(result) # results.append(result) # 关闭线程池 executor.shutdown() #将最终结果写入文件 with lock: rss.write(r'D:\\workspace\\script\\gzh_to_rss\\rss.xml', encoding='UTF-8', xml_declaration=True) print(\"write rss done\") def up_data_minio(bucket: str): minio_conf = { 'endpoint': '127.0.0.1:9000', 'access_key': 'xxxx', 'secret_key': 'xxxx', 'secure': False } client = minio.Minio(**minio_conf) client.fput_object(bucket_name=bucket, object_name='rss.xml',file_path='rss.xml',content_type='text/xml') print(\"syn rss.xml done\") if __name__ == \"__main__\": end_time = datetime.now() ## 定时查询 start_time = end_time - timedelta(hours=4) ## 获取最近4H内发表的文章 get_blog_list(\"https://wechat2rss.xlab.app/list/all.html\",start_time,end_time) up_data_minio('rss') 配置定时任务 使用crontab设置定时任务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ### ubuntu 系统检查 cron 包是否安装 dpkg -l cron ### 未安装 cron，先安装 cron 软件包 apt-get install cron ###验证 cron 服务是否正在运行 service cron status ### cron服务未启动，启动 service cron start ### 编辑当前用户cron服务，我选择vi编辑模式 crontab -e ### 每天9点定时运行python脚本 0 */4 * * * python /data/talebook/books/extract/603/blog_list_rss.py ### 为crontab增加日志 0 */4 * * * python /data/talebook/books/extract/603/blog_list_rss.py \u003e\u003e $HOME/for_crontab/mylog.log 2\u003e\u00261 minio部署 参考文章：\n部署私有对象存储服务: Minio 自建对象存储服务MinIO进行文件备份 Docker搭建minio文件服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ### 下载镜像 docker pull minio/minio ### 构建容器 docker run -p 9000:9000 --name minio -d --restart=always -e \"MINIO_ACCESS_KEY=admin\" -e \"MINIO_SECRET_KEY=admin123456\" -v /home/data:/data -v /home/config:/root/.minio minio/minio server /data --console-address \":9001\" ### 配置caddy xiaoqian713.live { reverse_proxy 127.0.0.1:9000 } console.xiaoqian713.live { reverse_proxy 127.0.0.1:9001 } ### 配置DNS解析(我用的cloudflare) A console 主机IP ### 配置minio 1. 网页登录console.xiaoqian713.live 2. 创建bucket，访问权限设置为public 最后 这种方式具备可行性的基础是开源项目wechat2rss持续的维护，谢谢ttttmr大佬 公众号订阅list中包含众多公众号，可以自行选择想订阅的公众号 可基于本文方案调整为只生成喜欢的公众号文章 ","description":"","tags":["rss","python","博客","MinIO"],"title":"使用feedly订阅公众号","uri":"/posts/gzh_to_rss/"},{"categories":["技术"],"content":"背景 最近使用uTools翻译功能时总会有些问题，使用不算方便一时冲动卸载了uTools。顺便重新整理了下日常使用的工具。\n截图工具由Snipaste 调整为 PixPin，增加了GIF录制，同时支持截图OCR 翻译工具由Pot提供 本地搜索直接使用everything 听歌软件从Listen1换成落雪音乐 搜索字符串加密解密工具时没有找到合适的工具，决定自己做一个\n实操 使用到的工具 GPT4 vscode + python pip install pycryptodome 算法库，提供aes，des等算法 pip install pyinstaller 打包库，打包成exe可执行程序 pip install wxPython GUI库 编码 完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 import wx from base64 import b64decode,b64encode from hashlib import md5 from Crypto.Cipher import AES from Crypto.Cipher import DES from Crypto.Util.Padding import pad, unpad class EncryptionFrame(wx.Frame): def __init__(self): super().__init__(None, title=\"加解密\", size=(820, 500)) self.app_icon = wx.Icon('favicon.ico', wx.BITMAP_TYPE_ICO) self.SetIcon(self.app_icon) self.panel = wx.Panel(self) # 算法选择相关组件 self.algorithm_sizer = wx.BoxSizer(wx.HORIZONTAL) self.algorithm_label = wx.StaticText(self.panel, label=\"选择算法:\") self.algorithm_combo = wx.ComboBox(self.panel, choices=[\"Base64\", \"MD5\", \"AES\", \"DES\"], style=wx.CB_READONLY) self.algorithm_combo.SetSelection(0) self.encrypt_button = wx.Button(self.panel, label=\"加密\") self.decrypt_button = wx.Button(self.panel, label=\"解密\") self.algorithm_sizer.Add(self.algorithm_label, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5) self.algorithm_sizer.Add(self.algorithm_combo, 0,wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 10) self.algorithm_sizer.Add(self.encrypt_button, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 10) self.algorithm_sizer.Add(self.decrypt_button, 0, wx.ALIGN_CENTER_VERTICAL, 10) # 输入输出文本相关组件 self.text_sizer = wx.BoxSizer(wx.HORIZONTAL) self.input_sizer = wx.BoxSizer(wx.VERTICAL) self.input_label = wx.StaticText(self.panel, label=\"输入:\") self.input_text = wx.TextCtrl(self.panel,style = wx.TE_MULTILINE) self.input_sizer.Add(self.input_label, 0, wx.ALL, 5) self.input_sizer.Add(self.input_text, 1,wx.EXPAND|wx.ALL) self.output_sizer = wx.BoxSizer(wx.VERTICAL) self.output_label = wx.StaticText(self.panel, label=\"输出:\") self.output_text = wx.TextCtrl(self.panel, style = wx.TE_READONLY | wx.TE_MULTILINE) self.output_sizer.Add(self.output_label, 0, wx.ALL, 5) self.output_sizer.Add(self.output_text, 1, wx.EXPAND|wx.ALL) self.text_sizer.Add(self.input_sizer,1, wx.EXPAND|wx.ALL, 10) self.text_sizer.Add(self.output_sizer,1, wx.EXPAND|wx.ALL, 10) # AES/DES加密参数相关组件 self.mode_sizer = wx.BoxSizer(wx.HORIZONTAL) self.mode_label = wx.StaticText(self.panel, label=\"加密模式:\") self.mode_combo = wx.ComboBox(self.panel, choices=[\"ECB\", \"CBC\", \"CFB\", \"OFB\"], style=wx.CB_READONLY) self.mode_combo.SetSelection(0) self.padding_label = wx.StaticText(self.panel, label=\"填充:\") self.padding_combo = wx.ComboBox(self.panel, choices=[\"pkcs7\", \"x923\",\"iso7816\"], style=wx.CB_READONLY) self.padding_combo.SetSelection(0) self.key_len_label = wx.StaticText(self.panel, label=\"秘钥长度:\") self.key_len_combo = wx.ComboBox(self.panel, choices=[\"128\", \"192\", \"256\"], style=wx.CB_READONLY) self.key_len_combo.SetSelection(0) self.key_label = wx.StaticText(self.panel, label=\"秘钥:\") self.key_text = wx.TextCtrl(self.panel) self.iv_label = wx.StaticText(self.panel, label=\"偏移量:\") self.iv_text = wx.TextCtrl(self.panel) self.out_mode_label = wx.StaticText(self.panel, label=\"输出格式:\") self.out_mode_combo = wx.ComboBox(self.panel, choices=[\"hex\"], style=wx.CB_READONLY) self.out_mode_combo.SetSelection(0) self.mode_sizer.Add(self.mode_label, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5) self.mode_sizer.Add(self.mode_combo, 0, wx.ALIGN_CENTER_VERTICAL, 5) self.mode_sizer.Add(self.padding_label, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5) self.mode_sizer.Add(self.padding_combo, 0, wx.ALIGN_CENTER_VERTICAL, 5) self.mode_sizer.Add(self.key_len_label, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5) self.mode_sizer.Add(self.key_len_combo, 0, wx.ALIGN_CENTER_VERTICAL, 5) self.mode_sizer.Add(self.key_label, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5) self.mode_sizer.Add(self.key_text, 0, wx.ALIGN_CENTER_VERTICAL, 5) self.mode_sizer.Add(self.iv_label, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5) self.mode_sizer.Add(self.iv_text, 0, wx.ALIGN_CENTER_VERTICAL, 5) self.mode_sizer.Add(self.out_mode_label, 0, wx.ALIGN_CENTER_VERTICAL|wx.RIGHT, 5) self.mode_sizer.Add(self.out_mode_combo, 0, wx.ALIGN_CENTER_VERTICAL, 5) for item in self.mode_sizer.GetChildren(): window = item.GetWindow() if window: # 如果item是一个窗口 window.Hide() self.sizer = wx.BoxSizer(wx.VERTICAL) self.sizer.Add(self.algorithm_sizer, 0, wx.EXPAND|wx.ALL, 5) self.sizer.Add(self.mode_sizer, 0, wx.EXPAND|wx.ALL, 5) self.sizer.Add(self.text_sizer, 1, wx.ALL|wx.EXPAND, 5) self.panel.SetSizer(self.sizer) self.algorithm_combo.Bind(wx.EVT_COMBOBOX, self.on_algorithm_change) self.mode_combo.Bind(wx.EVT_COMBOBOX, self.on_mode_change) self.encrypt_button.Bind(wx.EVT_BUTTON, self.OnEncrypt) self.decrypt_button.Bind(wx.EVT_BUTTON, self.OnDecrypt) self.Show() def OnEncrypt(self, event): self.output_text.SetValue(\"\") algorithm = self.algorithm_combo.GetValue() input_text = self.input_text.GetValue() # 根据选择的算法进行加密操作 if algorithm == \"Base64\": encrypted_text = base64_encode(input_text) elif algorithm == \"MD5\": encrypted_text = md5_encode(input_text) elif algorithm == \"AES\": encrypt_mode = self.mode_combo.GetValue() key_text = self.key_text.GetValue() key_len = self.key_len_combo.GetValue() iv_text = self.iv_text.GetValue() padding= self.padding_combo.GetValue() encrypted_text = aes_encrypt(key_text.encode('utf-8'),iv_text.encode('utf-8'),input_text,int(int(key_len)/8),padding,encrypt_mode) elif algorithm == \"RSA\": encrypted_text = aes_encrypt(input_text) elif algorithm == \"DES\": encrypt_mode = self.mode_combo.GetValue() key_text = self.key_text.GetValue() key_len = self.key_len_combo.GetValue() iv_text = self.iv_text.GetValue() padding= self.padding_combo.GetValue() encrypted_text = des_encrypt(key_text.encode('utf-8'),iv_text.encode('utf-8'),input_text,padding,encrypt_mode) else: encrypted_text = \"请选择算法\" self.output_text.SetValue(encrypted_text) def OnDecrypt(self, event): self.output_text.SetValue(\"\") algorithm = self.algorithm_combo.GetValue() input_text = self.input_text.GetValue() # 根据选择的算法进行解密操作 if algorithm == \"Base64\": decrypted_text = base64_decode(input_text) elif algorithm == \"MD5\": decrypted_text = md5_decode(input_text) elif algorithm == \"AES\": key_text = self.key_text.GetValue() encrypt_mode = self.mode_combo.GetValue() key_len = self.key_len_combo.GetValue() iv_text = self.iv_text.GetValue() padding= self.padding_combo.GetValue() decrypted_text = aes_decrypt(key_text.encode('utf-8'),iv_text.encode('utf-8'),bytes.fromhex(input_text),int(int(key_len)/8),padding,encrypt_mode) elif algorithm == \"RSA\": decrypted_text = aes_decrypt(input_text) elif algorithm == \"DES\": key_text = self.key_text.GetValue() encrypt_mode = self.mode_combo.GetValue() key_len = self.key_len_combo.GetValue() iv_text = self.iv_text.GetValue() padding= self.padding_combo.GetValue() decrypted_text = des_decrypt(key_text.encode('utf-8'),iv_text.encode('utf-8'),bytes.fromhex(input_text),padding,encrypt_mode) else: decrypted_text = \"请选择算法\" self.output_text.SetValue(decrypted_text) def on_algorithm_change(self, event): algorithm = self.algorithm_combo.GetValue() if algorithm in [\"AES\",\"DES\"]: for item in self.mode_sizer.GetChildren(): window = item.GetWindow() if window: # 如果item是一个窗口 window.Show() if self.mode_combo.GetValue() == \"ECB\": self.iv_label.Hide() self.iv_text.Hide() if algorithm == \"DES\": self.key_len_combo.Hide() self.key_len_label.Hide() elif algorithm == \"RSA\": for item in self.mode_sizer.GetChildren(): window = item.GetWindow() if window: # 如果item是一个窗口 window.Show() self.iv_label.Hide() self.iv_text.Hide() else: for item in self.mode_sizer.GetChildren(): window = item.GetWindow() if window: # 如果item是一个窗口 window.Hide() self.panel.Layout() def on_mode_change(self, event): mode = self.mode_combo.GetValue() if mode == \"ECB\": self.iv_label.Hide() self.iv_text.Hide() else: self.iv_label.Show() self.iv_text.Show() self.panel.Layout() def base64_encode(text): # 将字符串编码为字节流 byte_data = text.encode('utf-8') # 使用Base64进行编码 encoded_data = b64encode(byte_data) # 将字节流转换为字符串 encoded_text = encoded_data.decode('utf-8') return encoded_text def base64_decode(encoded_text): # 将字符串转换为字节流 byte_data = encoded_text.encode('utf-8') # 使用Base64进行解码 decoded_data = b64decode(byte_data) # 将字节流转换为字符串 decoded_text = decoded_data.decode('utf-8') return decoded_text def md5_encode(text): \"\"\" MD5 加密 :param text: 待加密文本 :return: 加密后的文本 \"\"\" m = md5() m.update(text.encode('utf-8')) return m.hexdigest() def md5_decode(text): \"\"\" MD5 解密 :param text: 待解密文本 :return: 解密后的文本 \"\"\" return \"MD5 不支持解密\" def customize_pad(s,BLOCK_SIZE): return s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * bytes([0]) def aes_encrypt(key, iv, data, block_size,padding,encrypt_mode): if len(key) \u003c block_size: key = customize_pad(key, block_size) else: key = key[:block_size] if len(iv) \u003c AES.block_size: iv = customize_pad(iv,AES.block_size) else: iv = iv[:AES.block_size] # 创建AES加密器\"ECB\", \"CBC\", \"CFB\", \"OFB\" cipher = None if encrypt_mode == \"ECB\": cipher = AES.new(key, AES.MODE_ECB) elif encrypt_mode == \"CBC\": cipher = AES.new(key, AES.MODE_CBC, iv) elif encrypt_mode == \"CFB\": cipher = AES.new(key, AES.MODE_CFB, iv) elif encrypt_mode == \"OFB\": cipher = AES.new(key, AES.MODE_OFB, iv) # 对数据进行填充 padded_data = pad(data.encode('utf-8'), AES.block_size, style=padding) # 加密数据 ciphertext = cipher.encrypt(padded_data) return ciphertext.hex() def aes_decrypt(key, iv,data, block_size,padding,encrypt_mode): if len(key) \u003c block_size: key = customize_pad(key, block_size) else: key = key[:block_size] if len(iv) \u003c AES.block_size: iv = customize_pad(iv,AES.block_size) else: iv = iv[:AES.block_size] # 创建AES解密器\"ECB\", \"CBC\", \"CFB\", \"OFB\" cipher = None if encrypt_mode == \"ECB\": cipher = AES.new(key, AES.MODE_ECB) elif encrypt_mode == \"CBC\": cipher = AES.new(key, AES.MODE_CBC, iv) elif encrypt_mode == \"CFB\": cipher = AES.new(key, AES.MODE_CFB, iv) elif encrypt_mode == \"OFB\": cipher = AES.new(key, AES.MODE_OFB, iv) # 解密数据 decrypted_data = cipher.decrypt(data) # 去除填充 unpadded_data = unpad(decrypted_data, AES.block_size, style=padding) return unpadded_data.decode('utf-8') def des_encrypt(key, iv, data,padding,encrypt_mode): if len(key) \u003c DES.block_size: key = customize_pad(key, DES.block_size) else: key = key[:DES.block_size] if len(iv) \u003c DES.block_size: iv = customize_pad(iv,DES.block_size) else: iv = iv[:DES.block_size] # 创建DES加密器\"ECB\", \"CBC\", \"CFB\", \"OFB\" cipher = None if encrypt_mode == \"ECB\": cipher = DES.new(key, DES.MODE_ECB) elif encrypt_mode == \"CBC\": cipher = DES.new(key, DES.MODE_CBC, iv) elif encrypt_mode == \"CFB\": cipher = DES.new(key, DES.MODE_CFB, iv) elif encrypt_mode == \"OFB\": cipher = DES.new(key, DES.MODE_OFB, iv) # 对数据进行填充 padded_data = pad(data.encode('utf-8'), DES.block_size, style=padding) # 加密数据 ciphertext = cipher.encrypt(padded_data) return ciphertext.hex() def des_decrypt(key, iv,data,padding,encrypt_mode): if len(key) \u003c DES.block_size: key = customize_pad(key, DES.block_size) else: key = key[:DES.block_size] if len(iv) \u003c DES.block_size: iv = customize_pad(iv,DES.block_size) else: iv = iv[:DES.block_size] # 创建DES加密器\"ECB\", \"CBC\", \"CFB\", \"OFB\" cipher = None if encrypt_mode == \"ECB\": cipher = DES.new(key, DES.MODE_ECB) elif encrypt_mode == \"CBC\": cipher = DES.new(key, DES.MODE_CBC, iv) elif encrypt_mode == \"CFB\": cipher = DES.new(key, DES.MODE_CFB, iv) elif encrypt_mode == \"OFB\": cipher = DES.new(key, DES.MODE_OFB, iv) # 解密数据 decrypted_data = cipher.decrypt(data) # 去除填充 unpadded_data = unpad(decrypted_data, DES.block_size, style=padding) return unpadded_data.decode('utf-8') if __name__ == \"__main__\": app = wx.App() frame = EncryptionFrame() frame.Show() app.MainLoop() 对GPT4提问：使用wxPython 编写一个用于字符串加解密的GUI。生成大概的GUI代码，然后根据生成代码进一步提问进行修改 base64，md5,ase，des算法实现都可以让GPT4生成 网页上找一个在线加解密网站，进行对比测试，修正bug 测试过程中发现ase/des算法，加密模式选择CFB时，python版本加密串可以自行解密，但加密结果与网页版不一致，原因未知 使用pyinstaller.exe 打包 推荐使用pyinstaller.exe -F -w -i favicon.ico main.py打包 icon文件与main.py放在同一层级 整体耗时1天，在编写日常软件时python和GPT搭配，可以极大提升效率 ","description":"","tags":["python","gpt"],"title":"利用GPT开发一个加解密算法工具","uri":"/posts/algorithm_tools/"},{"categories":["生活"],"content":"回顾23年印象深刻的事情寥寥无几，借此机会审视下23年的所作所为。\n生活 总体上家庭生活趋于稳定，个人在老公/父亲/儿子角色上的表现难说及格，想的多做的少。 与老婆结婚5年相识7年，现在称呼变成了孩子爸爸，孩子妈妈，以老公身份做的事情越来越少，感受不到用心二字。 小朋友突然很黏自己，但不知如何做好一名父亲，常常感到不安与无力。 6月底母亲住院做了房颤手术，整个住院期间没有去医院陪伴实属不该，一晃已经是上有老下有小，心态上觉得自己还是个孩子，没有承担起应有的责任与义务。 个人身体开始报警，上半年做了个肾结石手术，年底体检又检出结石，同时心脏时不时有胸闷的感觉，不重视锻炼过于懒惰。 与哥哥的关系有所改善，情商依然有待提高。 10月搭建了个人博客，同步编写公众号和小红书，初心是赚点小钱，希望可以坚持下去 上班通勤时开始听播客，过往接触的知识实在是太少了，越来越感觉到能力上的差距和行动上的不足 完成了24年的家庭预算，和老婆开始真的记账，慢慢提高家庭财务的稳定性 工作 公司经营状况出现了一些问题，公司人人自危，希望公司能越来越好，但是又无计可施。 今年做了一些有意义的项目，在业务中应用广泛，但是个人的成长明显放缓，未来不知何去何从。 未来想创建属于自己的工作室，目前完全不知道从何处下手，如何拆解目标，如何做准备。 24年规划 读6本书（两个月一本，希望可以完成），提高情商为家庭提供更稳定的情绪价值。 通过锻炼体重降到130斤，改善身体，提高家庭的抗风险能力。 拆解创建工作室这一目标，踏出第一步，慢慢开始试错 全年理财收益4% ","description":"","tags":["总结"],"title":"2023年总结","uri":"/posts/annual_review_2023/"},{"categories":["技术"],"content":"背景 最近准备看看《一只特立独行的猪》这本书，在找书过程中看到了很多有意思的开源项目和网站。考虑到有个服务器一直闲置，然后目的由找书变成了搭建个人的书城。\n资源 网站搭建talebook 网站搭建copyBook 24h搜书网 备胎书屋 必读推荐 网站搭建 talebook 支持epub,txt等格式，支持批量上传，搭建的网站简洁 copyBook 需要通过爬虫脚本将章节信息写入数据库，搭建的网站类似网络小说在线阅读网站 采用talebook 搭建网站，步骤很简单，按照说明文档进行部署就行。我采用docker进行的部署 docker-compose 安装 docker-compose.yml中/tmp/demo:/data调整为/data/talebook:/data 部署指令：docker-compose -f docker-compose.yml up -d 闲置的机器上采用caddy2进行反向代理 talebook部署完成后，修改/etc/caddy/Caddyfile新增reverse_proxy 127.0.0.1:8080 8080为docker-compose.yml中填写的端口 XXXX为对应的域名 使用对应域名即可访问网站 通过爬虫获取不同线上书城的书籍，上传到服务器指定的目录/data/talebook/book/imports，在网页通过批量同步方式导入网站 手机上下载kybook APP添加opds地址，支持搜索，书籍下载后阅读 1 2 3 4 5 6 7 XXXX { handle_path /XXXX { reverse_proxy 127.0.0.1:28727 } reverse_proxy 127.0.0.1:8080 } import sites/* 爬虫常用技能 scrapy爬虫 整体爬虫代码框架完全复用copyBook这个项目,只需在bookspider/bookspider/spider中添加解析文件 添加解析xx.py文件，并修改name参数为xx，编写好想要解析代码 修改copyBook\\bookspider\\start.py为cmdline.execute('scrapy crawl xx'.split()) 即可运行 yield scrapy.Request(bookUrl,meta={\"categoryName\":categoryName},callback=self.getBooks) bookUrl为完整的地址,getBooks为回调函数 getBooks中response为请求返回数据，如果地址是文件地址，则response.body即文件数据 allowed_domains 中为允许访问的域名，根据爬虫需要进行添加 scrapy使用代理 参考网络文章，修改copyBook\\bookspider\\bookspider\\settings.py未成功，直接在爬虫类中添加如下代码，验证代理通过\n1 2 os.environ[\"HTTP_PROXY\"] = \"http://127.0.0.1:1081\" os.environ[\"HTTPS_PROXY\"] = \"http://127.0.0.1:1081\" python运行js 1 2 3 4 5 6 7 def decode(self,data): path = os.path.split(os.path.realpath(__file__))[0] + '/xxx.js' with open(path, 'r', encoding='UTF-8') as f: js_code = f.read() context = execjs.compile(js_code) result = context.call(\"decode\", data) return result 安装PyExecJS，pip install PyExecJS context.call中decode为xxx.js中函数名，data为函数需要的参数 PyExecJS的运行依赖node.js xpath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def parse(self, response): authors_table = response.xpath(\"//article[@class='markdown-body']/table\") authors_ul = response.xpath(\"//article[@class='markdown-body']/ul\") for author in authors_table: author_name = \"\" author_url = \"\" if len(author.xpath(\"thead/tr/th/a/text()\").extract()) == 0 or len(author.xpath(\"thead/tr/th/a/@href\").extract()) == 0: continue else: author_name = author.xpath(\"thead/tr/th/a/text()\").extract()[0] author_url = author.xpath(\"thead/tr/th/a/@href\").extract()[0] author_url = author_url.replace(\"..\",\"\") yield scrapy.Request(self.base_url + author_url,meta={\"authorName\":author_name},callback=self.getBooks) authors_body = author.xpath(\"tbody/tr\") for author_body in authors_body: author_body_name = \"\" author_body_url = \"\" if len(author_body.xpath(\"td/a/text()\").extract()) == 0 or len(author_body.xpath(\"td/a/@href\").extract()) == 0: continue else: author_body_name = author_body.xpath(\"td/a/text()\").extract()[0] author_body_url = author_body.xpath(\"td/a/@href\").extract()[0] author_body_url = author_body_url.replace(\"..\",\"\") yield scrapy.Request(self.base_url +author_body_url,meta={\"authorName\":author_body_name},callback=self.getBooks) for author in authors_ul: author_name = \"\" author_url = \"\" if len(author.xpath(\"li/a/text()\").extract()) == 0 or len(author.xpath(\"li/a/@href\").extract()) == 0: continue else: author_name = author.xpath(\"li/a/text()\").extract()[0] author_url = author.xpath(\"li/a/@href\").extract()[0] author_url = author_url.replace(\"..\",\"\") yield scrapy.Request(self.base_url + author_url,meta={\"authorName\":author_name},callback=self.getBooks) len(author.xpath(\"thead/tr/th/a/text()\").extract())通过长度判断是否有值 author_name = author.xpath(\"thead/tr/th/a/text()\").extract()[0]取值 book.xpath(\"td[1]/text()\").extract() 列表索引从1开始 总结 github 真是效率工具，需要的各种工具都可以找到 scrapy 只使用了常规的能力，代理池、增量更新等还未涉及 ","description":"","tags":["scrapy","xpath","python"],"title":"搭建个人书城","uri":"/posts/scrapy_use/"},{"categories":["技术"],"content":"背景 最近有人对博客内容进行了评论，未收到任何通知，过了几天才发现，不利于沟通交流。因工作中经常使用企业微信，所以准备给Giscus系统增加一个企业微信通知功能。\n方案 google搜索资料,阅读为Giscus增加邮件通知功能，拉仇恨！webhook + 企业微信 给同事做了个代码提交监听工具等文章 方案初步明确：基于企业微信和github的webhook功能，增加一个转发服务即可。 最近使用cloudflare的worker功能，用的非常开心。基于cloudflare的worker服务利用js可以很好完成消息处理和转发。 方案成型:利用github的webhook将新增的discussion和comment信息转发给cloudflare worker中的js服务，js服务对消息处理后通过webhook转发企业微信 实现 在github中找到项目huhuhang/github-wechat-bot，此项目提供了基于 Cloudflare Workers 部署 API，支持基于 GitHub Webhook 将操作消息推送给企业微信机器人。只用支持Discussions的监控就行。\n按照项目的Readme，完成github/企业微信/cloudflare的设置，设置完成后在企业微信可以看到群机器人发送的ping请求。如果没有看到可以在github webhook页面，点击Recent Deliveries,可以重新发送。如果还没有看到可以执行检测设置是否正确。\ngithub webhook页面点Edit，然后勾选监控\"Discussion comments\",\"Discussions\"消息\n增加Discussions消息js处理代码，主要通过打印日志进行调试，最终js代码如下\ncloudflare在Logs-\u003eReal-time Logs-\u003eBegin log stream可以看到console.log打印的日志 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 /** * * @param {JSON} response 处理JSON格式的响应 * @returns */ async function gatherResponse(response) { const { headers } = response const contentType = headers.get(\"content-type\") || \"\" if (contentType.includes(\"application/json\")) { return JSON.stringify(await response.json()) } } /** * * @param {String} botKey 企业微信机器人密钥 * @param {String} content 需要发送的内容，支持 Markdown 格式 * @returns */ async function sendMdMsg(botKey, content) { const baseUrl = \"https://qyapi.weixin.qq.com/cgi-bin/webhook/\" const url = `${baseUrl}send?key=${botKey}` const init = { method: \"POST\", headers: { \"Content-Type\": \"application/json\" }, body: JSON.stringify({ \"msgtype\": \"markdown\", \"markdown\": { \"content\": content } }) } const response = await fetch(url, init) return await gatherResponse(response) } // 标记事件动作 const actionWords = { \"opened\": \"\u003cfont color='info'\u003e创建\u003c/font\u003e\", \"closed\": \"\u003cfont color='warning'\u003e关闭\u003c/font\u003e\", \"deleted\": \"\u003cfont color='info'\u003e删除\u003c/font\u003e\", \"reopened\": \"\u003cfont color='info'\u003e重新发起\u003c/font\u003e\", \"edited\": \"\u003cfont color='info'\u003e更新\u003c/font\u003e\", \"merge\": \"\u003cfont color='warning'\u003e合并\u003c/font\u003e\", \"created\": \"\u003cfont color='info'\u003e创建\u003c/font\u003e\", \"requested\": \"\u003cfont color='info'\u003e请求\u003c/font\u003e\", \"completed\": \"\u003cfont color='warning'\u003e完成\u003c/font\u003e\", \"synchronize\": \"\u003cfont color='info'\u003e同步更新\u003c/font\u003e\" }; /** * 处理 Ping 请求 * @param {String} botKey 企业微信机器人密钥 * @param {JSON} reqBody GitHub 传递的请求体 * @returns */ async function handlePing(botKey, reqBody) { const { hook, repository, organization } = reqBody; // 判定是组织还是仓库配置 Webhook if (hook.type == \"Organization\") { var mdMsg = \"成功收到了来自 Github 的 Ping 请求，组织: \" + organization.login; } else { var mdMsg = \"成功收到了来自 Github 的 Ping 请求，仓库地址: \" + repository.html_url; } return await sendMdMsg(botKey, mdMsg); } /** * 处理 PR 请求 * @param {String} botKey 企业微信机器人密钥 * @param {JSON} reqBody GitHub 传递的请求体 * @returns */ async function handlePR(botKey, reqBody) { const { action, sender, pull_request, repository } = reqBody; if (sender.type !== \"Bot\") { if (action == \"opened\" || action == \"reopened\") { const mdMsg = `${sender.login} 在 [${repository.full_name}](${repository.html_url}) ${actionWords[action]}了一个 PR: \u003e 分支: ${pull_request.head.ref} → ${pull_request.base.ref} \u003e 名称: [${pull_request.title}](${pull_request.html_url}) #${pull_request.number} \u003e 修改: ${pull_request.changed_files} 个文件 (\u003cfont color=\"info\"\u003e+ ${pull_request.additions}\u003c/font\u003e \u003cfont color=\"warning\"\u003e- ${pull_request.deletions}\u003c/font\u003e 行修改)`; return await sendMdMsg(botKey, mdMsg); } else if (action == \"closed\" \u0026\u0026 pull_request.merged) { const mdMsg = `${sender.login} 在 [${repository.full_name}](${repository.html_url}) ${actionWords[action]}了一个 PR: \u003e 分支: ${pull_request.head.ref} → ${pull_request.base.ref} \u003e 名称: [${pull_request.title}](${pull_request.html_url}) #${pull_request.number} \u003e 修改: ${pull_request.changed_files} 个文件 (\u003cfont color=\"info\"\u003e+ ${pull_request.additions}\u003c/font\u003e \u003cfont color=\"warning\"\u003e- ${pull_request.deletions}\u003c/font\u003e 行修改) \u003e 发起: ${pull_request.user.login} (${pull_request.created_at}) \u003e 审核: ${pull_request.merged_by.login} (${pull_request.review_comments} 条意见)`; return await sendMdMsg(botKey, mdMsg); } else { return `${action} 操作暂时不会被处理`; } } else { return `${sender.type} 操作暂时不会被处理`; } } /** * 处理 Issues 请求 * @param {String} botKey 企业微信机器人密钥 * @param {JSON} reqBody GitHub 传递的请求体 * @returns */ async function handleIssue(botKey, reqBody) { const { action, sender, issue, repository } = reqBody; if (action == \"opened\" || action == \"closed\" || action == \"reopened\") { const mdMsg = `${sender.login} 在 [${repository.full_name}](${repository.html_url}) ${actionWords[action]}了一个 Issues: \u003e 名称: [${issue.title}](${issue.html_url})`; return await sendMdMsg(botKey, mdMsg); } else { return `${action} 操作暂时不会被处理`; } } /** * 处理 discussion_comment 请求 * @param {String} botKey 企业微信机器人密钥 * @param {JSON} reqBody GitHub 传递的请求体 * @returns */ async function handle_discussion_comment(botKey, reqBody) { const { action, sender, comment, discussion } = reqBody; if (action == \"created\" || action == \"deleted\" || action == \"edited\") { const mdMsg = `${sender.login} 在 ${discussion.title}中${actionWords[action]}评论:${comment.body}`; return await sendMdMsg(botKey, mdMsg); } else { return `${action} 操作暂时不会被处理`; } } /** * 处理 Action 错误请求 * @param {String} botKey 企业微信机器人密钥 * @param {JSON} reqBody GitHub 传递的请求体 * @returns */ async function handleAction(botKey, reqBody) { const { action, sender, check_run, repository } = reqBody; // 如果状态完成且执行失败，则发送错误信息 if (action == \"completed\" \u0026\u0026 check_run.conclusion == \"failure\") { const mdMsg = `${sender.login} 在 [${repository.full_name}](${repository.html_url}) 中触发的 GitHub Action 执行\u003cfont color=\"warning\"\u003e失败\u003c/font\u003e了: \u003e 查看状态: [${check_run.name}](${check_run.html_url}) \u003e 错误信息: ${check_run.output.summary}`; return await sendMdMsg(botKey, mdMsg); } else { return `${action}(${check_run.conclusion}) 暂时不会被处理`; } } /** * * @param {JSON} request GitHub 传递的请求 * @returns */ async function handleRequest(request) { const { searchParams } = new URL(request.url) // 从 URL 获取传入的机器人密钥 let botKey = searchParams.get('key') // 从请求中获取消息内容 var reqBody = await gatherResponse(request) // 解析 GitHub 传递的消息类型 const gitEvent = request.headers.get(\"X-GitHub-Event\") console.log(`收到了一个 ${gitEvent} 事件`) switch (gitEvent) { // 如果是 Ping 事件 case \"ping\": var results = await handlePing(botKey, JSON.parse(reqBody)); break; // 如果是 PR 事件 case \"pull_request\": var results = await handlePR(botKey, JSON.parse(reqBody)); break; // 如果是 Issues 事件 case \"issues\": var results = await handleIssue(botKey, JSON.parse(reqBody)); break; // 如果是 Action 事件 case \"check_run\": var results = await handleAction(botKey, JSON.parse(reqBody)); break; // 如果是 discussion_comment 事件 case \"discussion_comment\": var results = await handle_discussion_comment(botKey,JSON.parse(reqBody)); break; // 其他事件暂不支持 default: var results = `暂不支持处理 ${gitEvent} 事件`; break; } return new Response(results) } addEventListener(\"fetch\", event =\u003e { const { request } = event // 仅处理 POST 请求 if (request.method === \"POST\") { return event.respondWith(handleRequest(request)) } else { return event.respondWith(new Response(\"使用方法请参考文档: https://github.com/huhuhang/github-wechat-bot\")) } }) 总结 下一阶段要学习下JS，结合cloudflare worker可以做出一些有意思的工具出来 以后看到有意思的产品，在脑海中有意识锻炼下如何通过不同的能力完成对应服务的搭建 最近工作软件切换成飞书，调整hook地址和sendMdMsg中的消息参数后，通知消息切换到飞书机器人 ","description":"","tags":["Hugo","代理","JS","cloudflare","Giscus"],"title":"为博客Giscus评论增加通知机器人","uri":"/posts/webhook_proxy/"},{"categories":["技术"],"content":"背景 使用hugo创建博客接近2个月，一直走在折腾样式的路上，随着不停的折腾，建立了对hugo初步的认识。本文主要用于梳理个人对hugo和前端知识的理解，同时希望能帮助对hugo和前端知识不熟悉的人，建立相关的概念。\n内容仅供参考，本人对前端知识了解不多，部分内容的理解必然存在问题。如果您发现了问题，欢迎在评论区留言指正。\n基础知识 首先建立hugo的工作原理，了解hugo的目录结构、shortcode使用、html的基础信息方便自定义修改。推荐阅读资料hugo官方文档\nhugo工作原理 hugo工作原理：我的理解是按照指定的规则生成html文件。 主题就是已经写好的转换规则，基于主题的自定义，就是修改转化规则 文章是将markdown文件，按照主题预设的规则转换成html 页面是将主题预设的规则和自定义规则，拼凑成html 自定义规则一般不会直接修改主题，而是在博客目录的assets、layouts、static/js中添加内容进行修改 hugo 目录结构 assets 用于存放scss文件，主要用于样式的渲染 content 用于存放.md文件，主要是文章内容和自定义页面 data 存放一些数据文件，自定义的结构化数据，比如JSON、YAML或TOML格式的文件。 layouts用来存放html元素文件，在页面指定的位置添加元素内容，定义页面布局 static 不需要经过处理的静态文件，比如图片、样式表和脚本文件。 js 用于放js文件，用于动态的修改展示的信息 themes 目录包含自定义主题的文件，如果你使用了自定义主题的话。 hugo.toml 是网站的配置文件，用于定义网站的各种设置。 shortcode 按照模板在指定位置插入数据，常用语句如下 {{ .Get \"class\" }},取key为class的值 {{ .Inner }},取shortcode标签对之间的内容 {{ with .Get \"class\" }} class=\"{{ . }}\"{{ end }}，如果存在key为class 输出class=\"对应值\"，否则什么都不输出 {{ if (.Get \"title\")}} class=\"xxx\" {{else}} class=\"yyy\" {{ end }},如果存在key为title,class为\"xxx\"否则为\"yyy\" {{ .Get 0 }},按位置访问参数,取第一个参数的值 Hugo Shortcodes 示例 自定义 Hugo Shortcodes 简码 HTML html内容基本可以划分为以下几个部分: content: 这不是HTML标准元素，但可以是自定义元素。在Web组件中，可能会使用标签来插入组件内的内容。 footer: 通常用于网页底部，放置版权信息、联系方式、链接等内容。 head: 在HTML文档中表示头部部分，包含了页面的元数据和链接引用等信息，如标题、样式表链接、脚本引用等。 header: 通常用于网页顶部，包含网站的标题、导航栏等内容。 post-meta: 这同样不是HTML标准元素，可以是自定义元素。在博客或新闻网站中，可能会使用标签来展示文章的元信息，比如作者、发布日期等。 script: 用于在网页中嵌入JavaScript代码的标签，可以用于引入外部脚本或直接书写JavaScript代码。 此处内容详情由GPT3生成。 案例 评论使用Giscus meme主题最新版本已支持Giscus，在hugo.toml中添加配置即可使用。实现方案与本文内容类似\n具体操作流程参考文章安裝Giscus作為Hugo網站的留言板，支援轉換Gitalk/Utterances的留言 主要操作点如下：\n在github中启用Giscus功能 在\\layouts\\partials\\comments中添加giscus.html文件，粘贴Giscus官网中获取的Giscus代码 复制themes\\meme\\layouts\\partials\\pages\\post.html放到\\layouts\\partials\\pages\\中 修改\\layouts\\partials\\pages\\post.html 中{{ partial \"components/comments.html\" . }}为{{ partial \"comments/giscus.html\" . }} 评论无法动态切换成暗黑模式，修改\\themes\\meme\\assets\\js\\dark-mode.js中changeMode函数，增加下面代码 1 2 3 4 5 6 7 8 9 const giscusIframe = document.querySelector('.giscus-frame'); if (giscusIframe) { // 检测当前主题是否为暗黑模式 if (isDark) { giscusIframe.src = giscusIframe.src.replace('theme=light', 'theme=dark'); } else { giscusIframe.src = giscusIframe.src.replace('theme=dark', 'theme=light'); } } Lunr搜索支持中文 整体修复流程如下：\nlunr搜索官方不支持中文,google 找到了开源lurn扩展项目lunr-languages 在cdn.jsdelivr.net找到扩展项目对应lunr-zh.js地址，修改hugo.toml中lunr_lang参数lunr_lang=\"/npm/lunr-languages-zh@1.4.0/lunr.zh.js\"，在网页中测试不支持中文，查看网页html源码发现未引用lunr-zh.js 阅读主题源码是blog\\themes\\meme\\layouts\\partials\\third-party\\lunr-search.html中if in $supported $lang 过滤zh导致，在$supported中添加\"zh\",查阅页面html发现lunr-zh.js已引用，测试搜索仍然不支持中文，同时网页控制台报错未捕获的类型错误：nodejieba.cut 不是函数 查看lunr-languages issues提示原因是需要node运行，同时贴出了解决项目方案mochi-cards/lunr-languages 修复版本的lurn-zh.js无法通过在线地址方式导入，调整为本地导入。下载mochi-cards/lunr-languages项目中的lunr-zh.js文件放入/static/js中 在layouts/partials/custom创建script.html文件，填入\u003cscript src=\"/js/lunr.zh.js\" defer\u003e\u003c/script\u003e 修改lunr-search.html在线导入代码，{{- $scripts = union $scripts (slice $srcLang) -}}调整为{{- if eq $lang \"zh\" -}}{{- else -}}{{- $scripts = union $scripts (slice $srcLang) -}}{{- end -}} 运行测试控制台提示'Lunr is not present. Please include / require Lunr before this script.'，查看lurn-zh.js源码是 'undefined' === typeof lunr导致 因对前端知识不了解，只能通过控制变量进行测试定位问题。下载lurn-de.js文件，将引入lurn-zh.js文件调整为引入lurn-de.js文件，运行无报错。对比两个文件源码，lurn-zh.js中(this, function(Segment) { 比lurn-de.js多Segment参数，确定Segment未使用删除Segment参数，再次测试运行正常 在cdn.jsdelivr.net中找到支持中文的lurn.js,修改hugo.toml中lunr = \"/npm/lunr-zh-cn@0.7.1/lunr.min.js\",测试后对中文的搜索支持的更好。 整个修复流程使我对hugo的结构有了更一步的理解，同时也对meme主题有了更深的认知。\n创建说说页面 一直想在博客中增加说说功能，在对shortcode的使用慢慢熟悉后，开始动手操作将主题hugo-theme-moments的样式集成到博客中。\n解决思路：新建博客使用hugo-theme-moments主题，分析博客网页说说内容部分的html元素，抽象为shortcode。将说说部分对应的css、js文件集成博客中，最终使用shortcode发说说。\nhugo-theme-moments主题生成的网页中使用到的css和js信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u003cscript type=\"text/javascript\" src=\"https://unpkg.com/jquery@3.3.1/dist/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcss.com/jqueryui/1.12.1/jquery-ui.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js\"\u003e\u003c/script\u003e \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css\" /\u003e \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/purecss@2.0.6/build/grids-min.css\" /\u003e \u003clink rel=\"stylesheet\" href=\"https://unpkg.com/purecss@2.0.6/build/grids-responsive-min.css\" /\u003e \u003clink rel=\"stylesheet\" href=\"https://farseash.github.io/demo-hugo-theme-moments/style-refractored.min.f763c606ea7f621cac55d5419e71c55d50792a0b67ae61e88a8de81fa2cc2b3d.css\" /\u003e \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css\" /\u003e 抽象后的shortcode：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 文本内容shortcode \u003cdiv class=\"moment-row\"\u003e \u003cdiv class=\"pure-g\"\u003e \u003cdiv class=\"pure-u-1 pure-u-sm-1-3\"\u003e \u003cdiv class=\"time\"\u003e \u003cdiv class=\"month-day\"\u003e{{.Get \"date\"}}\u003c/div\u003e \u003cdiv class=\"year\"\u003e{{.Get \"year\"}}\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"pure-u-1 pure-u-sm-2-3\"\u003e \u003cdiv class=\"moment-content\"\u003e \u003cdiv style=\"padding-left: 5px; padding-right: 5px;\"\u003e \u003cdiv class=\"context\"\u003e \u003cp\u003e{{.Get \"content\"}}\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"pic-grid\" style=\"width: 53%\"\u003e \u003cdiv class=\"pure-g\"\u003e {{ .Inner }} \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"share-link-block\"\u003e {{with .Get \"url\"}}\u003cp class=\"url\"\u003e\u003ca href = {{ . }}\u003e{{ . }}\u003c/a\u003e\u003c/p\u003e{{end}} \u003c/div\u003e \u003c/div\u003e \u003chr\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e // 图片内容shortcode \u003cdiv class=\"pure-u-1-2\"\u003e \u003cdiv class=\"add-padding\"\u003e \u003cdiv class=\"img-container\"\u003e \u003ca data-src=\"{{ .Get \"url\" }}\" data-fancybox=\"gallery\" {{ with .Get \"caption\" }}data-caption=\"{{ . }}\"{{end}}\u003e \u003cimg src=\"{{ .Get \"url\" }}\" alt=\"pictures\" /\u003e \u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e 将用到的css信息下载下来放到assets/scss中，文件尾缀修改为scss layouts/partials/custom/script.html中增加上面贴出的js文件 layouts/shortcodes中新建moment.html和moment_image.html，将上面shortcode复制进去 为了只在说说页面使用相关的scss文件，在layouts/shortcodes中新建moments.html 新建页面和添加菜单操作不赘述，发说说使用如下语句即可 1 2 3 4 5 6 7 8 9 10 {{\u003c moments \u003e}} {{\u003c moment year = \"2023\" date = \"12.06\" content = \"更换博客主题，折腾博客比写文章快乐!\" \u003e}} {{\u003c /moment \u003e}} {{\u003c moment year = \"2023\" date = \"12.05\" content = \"第一条\" \u003e}} {{\u003c moment_image url = \"/moments/laugh.png\" \u003e}} {{\u003c /moment \u003e}} {{\u003c moments \u003e}} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //moments.html内容 {{ $options := (dict \"targetPath\" \"/css/style-refractored.css\" \"outputStyle\" \"compressed\" \"enableSourceMap\" true) }} {{ $style := resources.Get \"/scss/style-refractored.scss\" | resources.ToCSS $options }} {{ $options1 := (dict \"targetPath\" \"/css/grids-min.css\" \"outputStyle\" \"compressed\" \"enableSourceMap\" true) }} {{ $style1 := resources.Get \"/scss/grids-min.scss\" | resources.ToCSS $options1 }} {{ $options2 := (dict \"targetPath\" \"/css/grids-responsive-min.css\" \"outputStyle\" \"compressed\" \"enableSourceMap\" true) }} {{ $style2 := resources.Get \"/scss/grids-responsive-min.scss\" | resources.ToCSS $options2 }} {{ $options3 := (dict \"targetPath\" \"/css/fancybox.css\" \"outputStyle\" \"compressed\" \"enableSourceMap\" true) }} {{ $style3 := resources.Get \"/scss/fancybox.scss\" | resources.ToCSS $options3 }} \u003clink rel=\"stylesheet\" href=\"{{ $style.RelPermalink }}\"\u003e \u003clink rel=\"stylesheet\" href=\"{{ $style1.RelPermalink }}\"\u003e \u003clink rel=\"stylesheet\" href=\"{{ $style2.RelPermalink }}\"\u003e \u003clink rel=\"stylesheet\" href=\"{{ $style3.RelPermalink }}\"\u003e {{ .Get 0 }} {{ range split .Inner \"\\n\" }} {{ $line := replace . \" \" \" \" }} {{ printf \"%s\" $line | safeHTML }} {{ end }} bug修复 手机上搜索框不展示 页面上调试发现搜索框与其他菜单class值不同，搜索为class=\"menu-item search-item\"， 与其他菜单为class=\"menu-item\" 手动删除search-item显示正常，在代码中搜素search-item，删除menu.html中search-item即可修复此问题 说说页面无暗黑模式 将\\assets\\scss\\style-refractored.scss中color相关的代码删除，复用主题的色彩 总结 本文最想告知读者和自我总结的是:解决问题的思维方式。希望读者可以感受到这点，也希望本文可以帮助读者解决一些问题。 间隔1个月后再次阅读本文，整体文章内容偏多,结构不清晰，表述能力需要加强 ","description":"","tags":["hugo","tips"],"title":"Hugo使用小结","uri":"/posts/hugo_tips/"},{"categories":["技术"],"content":"背景 日常写文章同步公众号已经有自动化工具辅助，但是发布到小红书还是需要经过重新编辑非常不方便。前段时间听播客的时候，听到一个方案是将html转换成图片，然后在小红书上只发布图片，解决了重新编辑和文章字数限制。目前适合我的脚本已编写完成，记录下整体流程。\n方案 在同步公众号的脚本中将markdown文件转换成了html文件，利用selenium加载html文件全文截图，然后按照标题坐标将不同段落转换成图片。之后再借助selenium模拟点击小红书发布流程，实现全自动化文章发布。 首先在github上查找是否有合适的脚本，找到一个自动发布小红书视频脚本 html转图片 最开始试用了很多库例如html2image,imgkit,pyppeteer等，因为可扩展性和不熟悉放弃，最终选用了PIL和selenium\n最初采用设置窗口宽高方案截图，但是无法便捷的裁剪指定区域。调整为对整个文章进行截图，然后根据标题左上角的坐标确定裁剪区域\n阅读webdriver.py API发现可以使用set_window_rect设置截图的坐标实现相应功能，读者可自行实验\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 import os.path from PIL import Image from selenium import webdriver from selenium.webdriver.common.by import By import time def html_to_png(html_path,out_path): # options = webdriver.ChromeOptions() options = webdriver.EdgeOptions() options.add_argument('--headless') # 不知为啥只能在无头模式执行才能截全屏 options.add_argument('--disable-gpu') driver = webdriver.Edge(options=options) # driver = webdriver.Chrome(options=options) driver.maximize_window() try: driver.get(html_path) sections = driver.find_elements(By.XPATH, \"//h3 | //h4\") h3_height_list = [] for section in sections: # 使用JavaScript执行脚本来获取章节元素在网页中的位置信息 location = driver.execute_script(\"return arguments[0].getBoundingClientRect();\", section) h3_height_list.append((location['left'],location['top'])) index = 0 size = [] scroll_width = driver.execute_script('return document.body.parentNode.scrollWidth') scroll_height = driver.execute_script('return document.body.parentNode.scrollHeight') driver.set_window_size(scroll_width, scroll_height) driver.get_screenshot_as_file(out_path + \"screenshot.png\") for item in h3_height_list: if index \u003e 0: screenshot = Image.open(out_path + \"screenshot.png\") # 裁剪出感兴趣的位置 cropped_image = screenshot.crop((0, int(size[1]), scroll_width, int(item[1]))) # 保存裁剪后的图片 cropped_image.save(out_path + \"%d.png\" % index) size = item index += 1 cropped_image = screenshot.crop((0, int(size[1]), scroll_width, scroll_height)) # 保存裁剪后的图片 cropped_image.save(out_path + \"%d.png\" % index) os.remove(out_path + \"screenshot.png\") driver.quit() except Exception as e: print(e) if __name__ == '__main__': _HTML = 'D:\\\\workspace\\\\script\\\\push_to_gzh\\\\article\\\\out\\\\index_cp_article_wx.html' _OUTFILE = 'D:\\\\workspace\\\\script\\\\push_to_xiaohongshu\\\\out\\\\' # 首先创建一个保存截图的文件夹 if not os.path.isdir(_OUTFILE): # 判断文件夹是否存在，如果不存在就创建一个 os.makedirs(_OUTFILE) # 将html转换成png html_to_png(\"file:///\"+_HTML,_OUTFILE) 自动发图文 自动发布小红书视频脚本功能很完善，微微调整就可以使用 **vidoe.send_keys(mp4[0])**中mp4[0]调整为图片地址 for label in [\"#虐文\",\"#知乎文\",\"#小说推荐\",\"#知乎小说\",\"#爽文\"]: 标签通过参数传递 get_publish_date 函数简化，不像定时发布可注释相应代码 安装selenium后，第一次执行webdriver.EdgeOptions()时会下载相应驱动，耗时会有点久 自动发布视频函数未经测试，如有bug可自行调整 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 import json import os import time import traceback from datetime import datetime,timedelta from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.common.keys import Keys XIAOHONGSHU_COOKING = r'D:\\workspace\\script\\push_to_xiaohongshu\\out\\config.json' def get_driver(): options = webdriver.EdgeOptions() # options.add_argument('--headless') # 不知为啥只能在无头模式执行才能截全屏 # options.add_argument('--disable-gpu') driver = webdriver.Edge(options=options) driver.maximize_window() return driver def xiaohongshu_login(driver): if (os.path.exists(XIAOHONGSHU_COOKING)): print(\"cookies存在\") with open(XIAOHONGSHU_COOKING) as f: cookies = json.loads(f.read()) driver.get(\"https://creator.xiaohongshu.com/creator/post\") driver.implicitly_wait(10) driver.delete_all_cookies() time.sleep(4) # 遍历cook print(\"加载cookie\") for cookie in cookies: if 'expiry' in cookie: del cookie[\"expiry\"] # 添加cook driver.add_cookie(cookie) # 刷新 print(\"开始刷新\") driver.refresh() driver.get(\"https://creator.xiaohongshu.com/publish/publish\") time.sleep(5) else: print(\"cookies不存在\") driver.get('https://creator.xiaohongshu.com/creator/post') # driver.find_element( # \"xpath\", '//*[@placeholder=\"请输入手机号\"]').send_keys(\"\") # # driver.find_element( # # \"xpath\", '//*[@placeholder=\"请输入密码\"]').send_keys(\"\") # driver.find_element(\"xpath\", '//button[text()=\"登录\"]').click() print(\"等待登录\") time.sleep(30) print(\"登录完毕\") cookies = driver.get_cookies() with open(XIAOHONGSHU_COOKING, 'w') as f: f.write(json.dumps(cookies)) print(cookies) time.sleep(1) def get_publish_date(): tomorrow = now = datetime.today() if(now.hour \u003e 20): tomorrow = now + timedelta(days = 1) tomorrow = tomorrow.replace(hour=20) else: tomorrow = tomorrow.replace(hour=20,minute=0) return tomorrow.strftime(\"%Y-%m-%d %H:%M\") def publish_xiaohongshu_video(driver, mp4, index): driver.find_element(\"xpath\", '//*[text()=\"发布笔记\"]').click() print(\"开始上传文件\", mp4[0]) time.sleep(3) # ### 上传视频 vidoe = driver.find_element(\"xpath\", '//input[@type=\"file\"]') vidoe.send_keys(mp4[0]) # 填写标题 content = mp4[1].replace('.mp4', '') driver.find_element( \"xpath\", '//*[@placeholder=\"填写标题，可能会有更多赞哦～\"]').send_keys(content) time.sleep(1) # 填写描述 content_clink = driver.find_element( \"xpath\", '//*[@placeholder=\"填写更全面的描述信息，让更多的人看到你吧！\"]') content_clink.send_keys(content) time.sleep(3) # #虐文推荐 #知乎小说 #知乎文 for label in [\"#虐文\",\"#知乎文\",\"#小说推荐\",\"#知乎小说\",\"#爽文\"]: content_clink.send_keys(label) time.sleep(1) data_indexs = driver.find_elements( \"class name\", \"publish-topic-item\") try: for data_index in data_indexs: if(label in data_index.text): print(\"点击标签\",label) data_index.click() break except Exception: traceback.print_exc() time.sleep(1) # 定时发布 dingshi = driver.find_elements( \"xpath\", '//*[@class=\"css-1v54vzp\"]') time.sleep(4) print(\"点击定时发布\") dingshi[3].click() time.sleep(5) input_data = driver.find_element(\"xpath\", '//*[@placeholder=\"请选择日期\"]') input_data.send_keys(Keys.CONTROL,'a') #全选 # input_data.send_keys(Keys.DELETE) input_data.send_keys(get_publish_date()) time.sleep(3) # driver.find_element(\"xpath\", '//*[text()=\"确定\"]').click() # 等待视频上传完成 while True: time.sleep(10) try: driver.find_element(\"xpath\",'//*[@id=\"publish-container\"]/div/div[2]/div[2]/div[6]/div/div/div[1]//*[contains(text(),\"重新上传\")]') break except Exception as e: traceback.print_exc() print(\"视频还在上传中···\") print(\"视频已上传完成！\") time.sleep(3) # 发布 driver.find_element(\"xpath\", '//*[text()=\"发布\"]').click() print(\"视频发布完成！\") time.sleep(10) def publish_xiaohongshu_image(driver, image_path,title,describe,keywords): time.sleep(3) driver.find_element(\"xpath\", '//*[text()=\"发布笔记\"]').click() print(\"开始上传图片\") time.sleep(3) # ### 上传图片 driver.find_element(\"xpath\", '//*[text()=\"上传图文\"]').click() push_file = driver.find_element(\"xpath\", '//input[@type=\"file\"]') file_names = os.listdir(image_path) # 打印所有文件名 for file_name in file_names: push_file.send_keys(image_path + \"\\\\\"+file_name) # 填写标题 driver.find_element( \"xpath\", '//*[@placeholder=\"填写标题，可能会有更多赞哦～\"]').send_keys(title) time.sleep(1) # 填写描述 content_clink = driver.find_element( \"xpath\", '//*[@placeholder=\"填写更全面的描述信息，让更多的人看到你吧！\"]') content_clink.send_keys(describe) time.sleep(3) # #虐文推荐 #知乎小说 #知乎文 for label in keywords: content_clink.send_keys(label) time.sleep(1) data_indexs = driver.find_elements( \"class name\", \"publish-topic-item\") try: for data_index in data_indexs: if(label in data_index.text): print(\"点击标签\",label) data_index.click() break except Exception: traceback.print_exc() time.sleep(1) # 定时发布 dingshi = driver.find_elements( \"xpath\", '//*[@class=\"css-1v54vzp\"]') time.sleep(4) print(\"点击定时发布\") dingshi[3].click() time.sleep(5) input_data = driver.find_element(\"xpath\", '//*[@placeholder=\"请选择日期\"]') input_data.send_keys(Keys.CONTROL,'a') #全选 # input_data.send_keys(Keys.DELETE) input_data.send_keys(get_publish_date()) time.sleep(3) # driver.find_element(\"xpath\", '//*[text()=\"确定\"]').click() # 发布 driver.find_element(\"xpath\", '//*[text()=\"发布\"]').click() print(\"图文发布完成！\") time.sleep(10) if __name__ == \"__main__\": try: title = \"测试下\" describe = ['#python','#礼物'] driver = get_driver() xiaohongshu_login(driver=driver) # publish_xiaohongshu_video(driver, r\"D:\\workspace\\script\\push_to_xiaohongshu\\out\\9.png\", 1) publish_xiaohongshu_image(driver, r\"D:\\workspace\\script\\push_to_xiaohongshu\\out\", title,describe) finally: driver.quit() 总结 selenium是个非常强大的库，可以实现很多自动化的工作。第一次使用被惊艳到，这也是代码的迷人之处，期待后续使用selenium做的小工具。\n","description":"","tags":["python","自动化"],"title":"懒人必备，自动发小红书","uri":"/posts/publish_xhs/"},{"categories":["技术"],"content":"背景 临近老婆生日思考该送什么，经常看到别人自己写个软件送个老婆，程序员的浪漫永远这么的耿直。\n整体流程 确定方向 日常老婆经常让我帮她下载B站和好看视频的内容，同时老婆对计算机一窍不通，只会点点点。最终确定给老婆写个支持下载B站和好看视频带GUI的软件。\n确定方案 本人日常有使用yt-dlp下载youtube和b站视频，就这样敲定了下载的核心 本人很少使用python写gui程序，因而需要找一个yt-dlp的gui开源项目，减少开发难度 经过寻找开源项目youtube-dl-gui很适合，虽然已经停止维护6年 好看视频直接爬取网页中视频链接，然后对视频链接进行下载 youtube-dl-gui改造 主要调整为将python2调整为python3,根据调试报错进行针对性修正，修正过程不赘述\n可以使用代码对比工具自行对比yt-dlp-gui与youtube-dl-gui 将下载器调整为yt-dlp.exe,参数YOUTUBEDL_BIN最初调整为本地yt-dlp.exe目录，因为实时下载功能未完成，将yt-dlp.exe放到/data/exe/目录下方便后续打包，同时YOUTUBEDL_BIN也调整为获取运行目录加上相对路径\n1 2 3 4 YOUTUBEDL_BIN = os.getcwd() if os.name == 'nt': YOUTUBEDL_BIN += '/_internal/exe/yt-dlp.exe' python打包成exe 主要参考PyInstaller打包Python项目详解\n操作流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 # 1.执行命令，__main__.py为程序入口文件 pyinstall -D __main__.py # 2.删除生成的bulid和dist文件夹,仅保留__main__.spec文件 # 3.修改__main__.spec文件,素材和yt-dlp.exe加入打包 # -*- mode: python ; coding: utf-8 -*- a = Analysis( ['__main__.py'], pathex=['D\\\\workspace\\\\youtube_dl_gui'], binaries=[('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\exe\\\\yt-dlp.exe','exe')], datas=[('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\icons\\\\hicolor\\\\128x128\\\\apps\\\\youtube-dl-gui.png','data\\\\icons\\\\hicolor'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\icons\\\\hicolor\\\\16x16\\\\apps\\\\youtube-dl-gui.png','data\\\\icons\\\\hicolor'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\icons\\\\hicolor\\\\256x256\\\\apps\\\\youtube-dl-gui.png','data\\\\icons\\\\hicolor'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\icons\\\\hicolor\\\\32x32\\\\apps\\\\youtube-dl-gui.png','data\\\\icons\\\\hicolor'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\icons\\\\hicolor\\\\48x48\\\\apps\\\\youtube-dl-gui.png','data\\\\icons\\\\hicolor'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\icons\\\\hicolor\\\\64x64\\\\apps\\\\youtube-dl-gui.png','data\\\\icons\\\\hicolor'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\arrow_down_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\arrow_up_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\camera_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\cloud_download_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\delete_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\folder_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\icons-license','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\pause_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\play_arrow_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\reload_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\settings_20px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\stop_32px.png','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\youtube-dl-gui.ico','data\\\\pixmaps'), ('D:\\\\workspace\\\\youtube_dl_gui\\\\data\\\\pixmaps\\\\youtube-dl-gui.png','data\\\\pixmaps')], hiddenimports=[], hookspath=[], hooksconfig={}, runtime_hooks=[], excludes=[], noarchive=False, ) pyz = PYZ(a.pure) exe = EXE( pyz, a.scripts, [], exclude_binaries=True, name='youtube_dl_gui', debug=False, bootloader_ignore_signals=False, strip=False, upx=True, console=False, disable_windowed_traceback=False, argv_emulation=False, target_arch=None, codesign_identity=None, entitlements_file=None, ) coll = COLLECT( exe, a.binaries, a.datas, strip=False, upx=True, upx_exclude=[], name='__main__', ) # 4.执行命令 pyinstaller __main__.spec # 5.去dist文件夹下找youtube_dl_gui.exe文件,运行自测 # 6.运行成功，删除临时文件目录build；dist目录为打包的结果，可执行文件和其它程序运行的关联文件都在这个目录下 支持好看视频下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def get_video(self): base_url = self.bv headers = { \"user-agent\": \"Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1\" } try: response = requests.get(url=base_url, headers=headers, timeout=5) if response.status_code == 200: # soup = BeautifulSoup(response.text, 'html.parser') html = response.text start = html.find(\"window.__PRELOADED_STATE__ = \") end = html.find(\"}};\", start) json_str = html[start+len(\"window.__PRELOADED_STATE__ = \"):end+2] json_data = json.loads(json_str) title= json_data['curVideoMeta']['title'] videoInfo = json_data['curVideoMeta']['clarityUrl'] url = '' for item in videoInfo: if item['key'] == 'sc': url = item['url'] return title,url except Exception as e: return '','' 测试上述代码获取对应页面视频链接无误 在downloaders.py中添加HaoKanDownloader类，添加下载和下载进度代码 重新打包后，运行exe提示OPENSSL_Uplink{00007FFE7BF17068,08}: no OPENSSL_Applink 尝试issue中的方法，使用官方__ssl.pyd覆盖codna DLLs中的文件，解决此报错提示另外报错，将conda DLLs中所有文件全部用官方DLLs中文件替换后运行正常无报错，但是下载B站视频失败 回滚第4部操作，尝试将requests替换为urllib.request，返回的数据中视频地址被加密 找到项目crawler中支持好看视频信息获取，发起请求同样使用requests，调整为urllib.request.Request后验证可以正常使用 再次打包成exe,运行正常无报错，下载B站和好看视频正常，设置代理后可以下载youtube视频 总结 后续修改开源项目过程中，程序报错需要顺手截图留存，方便后续文章编写使用 通过此项目熟悉了wxPython基础，后续可以依葫芦画瓢 此前python基本作为脚本语言使用，后续可以在小型项目使用 ","description":"","tags":["python","下载","gui"],"title":"写个视频下载器送给老婆","uri":"/posts/download_video/"},{"categories":["技术"],"content":"背景 创建博客到现在，使用过程中存在以下问题\nhugo.toml中有敏感信息，每次提交代码时都额外需要注意 git 提交记录中包含敏感信息 公众号APP_ID和APP_SECRET保护 解决方案 hugo.toml 参考hugo 使用 github actions 保存源码和自动化构建 新建一个私有仓库blog，存储博客源文件 设置github 'Personal access tokens',在私有仓库blog中绑定用于后续自动推送 在私有仓库blog中创建自动化流程，脚本放在项目根目录 .github/workflows/deploy.yml,最后的文件名自行定义 文章内容推送到私有仓库blog，通过Action进行hugo编译，然后将blog内容同步到xiaoshame.github.io(博客仓库) xiaoshame.github.io 仓库中部署模式需要调整，setting-\u003ePages-\u003eBuild and deployment选'Deploy from a branch'，选择对应分支保存即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 name: deploy on: push: branches: - main workflow_dispatch: jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 ref: main # 这里选择你触发部署的分支！默认是 master - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \"latest\" extended: true # 用 stack 主题需要加这个配置 - name: Build Web run: hugo --minify - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: xiaoshame/xiaoshame.github.io # 改成你的仓库 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} Git git 的配置分为三级别，System -\u003e Global -\u003eLocal，优先级是 Local\u003e Global\u003e System。\n直接在项目下设置用户名和邮箱,注意其他的项目还是用的 Global中的配置\n1 2 git config --local user.name \"jitwxs\" git config --local user.email \"jitwxs@foxmail.com 公众号 通过系统环境变量保存，windows 我的电脑-\u003e属性-\u003e高级系统设置-\u003e环境变量-\u003e系统变量，PATH中设置 adfa 1 2 robot.config[\"APP_ID\"] = os.environ.get(\"WX_GZH_APP_ID\") robot.config[\"APP_SECRET\"] = os.environ.get(\"WX_GZH_APP_SECRET\") 待完成 目前获取文章摘要 和 自动推送微信公众号还需要单独运行两个脚本，后续计划将这两个操作合并到Action操作中，有一个问题是怎么控制微信公众号推送的时机\n","description":"","tags":["hugo","CI","github"],"title":"Hugo+Github零成本搭建博客流程记录2","uri":"/posts/hugo_blog2/"},{"categories":["技术"],"content":"背景 文章自动同步到公众号上传到公众号草稿箱后，因公众号接口原因导致排版存在问题，无法做到直接发布。排版问题如下：\n代码无法展示完整 有序列表前面的数字无法展示 无须列表多了几列 三级/四级标题样式固化 最后的参考内容数字列表格式错乱 解决方案 查阅资料找到markdown文件转html开源项目hzwz-markdown-wx。hzwz-markdown-wx项目存在如下问题：\n生成的html文件复制到微信公众号操作，实操失败\n生成的html文件无法自动投稿到公众号\n使用highlight对code高亮生成的html文件上传公众号报错\n1 2 Invalid JSON: Expecting value: line 1 column 1 (char 0) \u003c!DOCTYPE html\u003e\u003chtml\u003e\u003chead\u003e\u003cscript\u003evar i=location.href;var v=window.btoa?window.btoa(window.encodeURIComponent(i)):\"\";window.location.href=\"https://waf.tencent.com/501page.html?u=\"+location.origin+\"\u0026id=1b5cfa348bdfe54f018dcc316bcbf1cf-1697099164938977-85119-139672863803136-76234149314225168\u0026st=01\u0026v=\"+v;\u003c/script\u003e\u003c/head\u003e\u003c/html\u003e 整体方案是将文章自动同步到公众号中的markdown-to-wechat方案与hzwz-markdown-wx融合。\n核心改动介绍 修改sync.py中upload_media_news函数，只保留发布草稿箱功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def upload_media_news(content,baseinfo,token): \"\"\" 上传到微信公众号 \"\"\" articles = { 'articles': [ { \"title\": baseinfo.TITLE, \"thumb_media_id\": baseinfo.THUMB_MEDIA_ID, \"author\": baseinfo.AUTHOR, \"digest\": baseinfo.digest, \"show_cover_pic\": 1, \"content\": content, \"content_source_url\": baseinfo.CONTENT_SOURCE_URL } # 若新增的是多图文素材，则此处应有几段articles结构，最多8段 ] } headers={'Content-type': 'text/plain; charset=utf-8'} datas = json.dumps(articles, ensure_ascii=False).encode('utf-8') # 发布草稿箱 postUrl = \"https://api.weixin.qq.com/cgi-bin/draft/add?access_token=%s\" % token r = requests.post(postUrl, data=datas, headers=headers) try: resp = json.loads(r.text) media_id = resp['media_id'] print(media_id) # ### 发布 # media_params = { # \"media_id\": media_id # } # postUrl = \"https://api.weixin.qq.com/cgi-bin/freepublish/submit?access_token=%s\" % token # datas = json.dumps(media_params, ensure_ascii=False).encode('utf-8') # r = requests.post(postUrl,data=datas, headers=headers) # resp = json.loads(r.text) # print(resp) return True except json.JSONDecodeError as e: # 捕获JSON解码错误 print(\"Invalid JSON:\", e) print(r.text) return False except KeyError as e: # 捕获键错误 print(\"Key Error:\", e) print(r.text) return False app.py增加同步图片素材、获取文章基本信息、文章投稿等操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 if __name__ == '__main__': print() # 相关文件夹初始化 if cp_utils.is_dir_existed(md_dir) or cp_utils.is_dir_existed(out_dir): print(\"目录不存在\") exit(0) if cp_utils.is_dir_existed(styles_dir) or cp_utils.is_dir_existed(template_dir): print(\"目录不存在\") exit(0) # 文件检查/ md_file_path_list = cp_utils.filter_file_type(md_dir, '.md') if len(md_file_path_list) == 0: print(\"当前目录无md文件，请检查后重试！\" + md_dir) exit(0) theme_file_path_list = cp_utils.filter_file_type(styles_dir, '.ini') if len(theme_file_path_list) == 0: print(\"当前目录无样式配置文件，请检查后重试！\" + styles_dir) exit(0) print(\"begin sync to wechat\") start_time = time.time() # 开始时间 sync.init_cache() client, token = sync.Client() for md_file_path in md_file_path_list: split_list = md_file_path.split(os.sep) if len(split_list) \u003e 0: file_name = split_list[-1] print(\"读取文件 →\", file_name) file_content = cp_utils.read_file_content(md_file_path) ## 图片资源上传微信公众号 file_content,imageId = sync.update_images_urls(file_content,client) ## 获取文章基础信息 baseinfo = sync.BaseInfo(file_content,imageId,md_file_path) for theme_file_path in theme_file_path_list: theme_name = theme_file_path.split(os.sep)[-1][:-4] print(\"应用样式 →\", theme_name) renderer_content = render_article(file_content, theme_file_path, template_dir) out_file_path = os.path.join(out_dir, file_name.replace(\".md\", \"_{}.html\".format(theme_name))) print(\"输出文件 →\", out_file_path) cp_utils.write_file(renderer_content, out_file_path) if sync.upload_media_news(renderer_content,baseinfo,token): sync.cache_update(md_file_path) print(\"sync \" + md_file_path + \" to wechat successful\") 修改styles_renderer.py增加去掉md中文章描述信息，修改block_code函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 代码块 def block_code(self, code, info=None): if self.mac_window_template is not None: highlight_result = renderer_by_node(code, self.codestyle, info) return self.mac_window_template.render(text=highlight_result) else: exts = ['markdown.extensions.extra', 'markdown.extensions.tables', 'markdown.extensions.toc', 'markdown.extensions.sane_lists', codehilite.makeExtension( guess_lang=False, noclasses=True, pygments_style='friendly' ),] if info is not None: info = info.strip() lang = '' if info: lang = info.split(None, 1)[0] code = \"```\"+ lang + '\\n' + code + \"```\" html = markdown.markdown(code, extensions=exts) return replace_return(html) 对html了解不多，利用markdown.markdown完成代码高亮，规避使用highlight进行代码高亮无法投稿的问题\n使用总结 blog\\push_to_gzh\\config.ini中控制相关资源目录地址 blog\\push_to_gzh\\styles\\custom\\cp_article_wx.ini 配置文章样式 codespan和codestyle配置不可用，会导致文章介绍的投稿失败问题。 css_beautify函数可以美化html文件，使用blog\\push_to_gzh\\template\\author\\assets中的文件实现 完整的代码已上传github可自行查看 ","description":"","tags":["CI","效率"],"title":"文章自动同步到公众号2","uri":"/posts/article_auto_push_gzh2/"},{"categories":["技术"],"content":"背景 受如何无痛苦更新公众号影响，开始思考如何应用到我的日常文章编写中。\n操作记录 完整代码已同步个人仓库，修正pickle运行问题，代码高亮后无滚动条问题。\n脚本原理：\n利用markdown库实现md文件转换成html文件 利用codehilite 实现代码高亮 利用微信开发者API，基于werobot库完成图片资源上传和文章同步到草稿箱 运行前提：\n在公众号设置与开发-基本配置，获取个人APP_ID和APP_SECRET填入脚本 在公众号设置与开发-基本配置，将运行脚本的机器出口IP加入公众号白名单 修改blog_path为需要同步的文章地址 不足：\n可以对文章进行发布，腾讯公众号发布的定义是粉丝无法看到文章。文章群发后粉丝才能看到，但是腾讯开发者API未提供群发接口。\n","description":"","tags":["CI","效率"],"title":"文章自动同步到公众号","uri":"/posts/article_auto_push_gzh/"},{"categories":["技术"],"content":"背景 组内使用github-runner进行代码规范检测，最近运维进行存储切换导致代码检测运行失败，之前找其他人安装的，年久无人维护只能自己上，记录整个过程。本文默认大家了解gitlab-runner的基础知识，不了解的可以先阅读参考资料中的文章。\n问题排查 我们代码检测主要用的cppcheck和cpplint，查看Github-Runner jobs报错，发现是对应的镜像文件找不到，首先恢复镜像\n1 2 3 4 Preparing the \"docker\" executor 00:48 Using Docker executor with image 10.1.107.12:5000/dy/cppcheck ... ERROR: Preparation failed: adding cache volume: set volume permissions: running permission container \"a192958483eb385c5a19432a82b4bfd20d54a7a7cd28a35e3c3f85938bc8ab31\" for volume \"runner-bcvnjjb9-project-11377-concurrent-0-cache-3c3f060a0374fc8bc39395164f415a70\": starting permission container: Error response from daemon: error evaluating symlinks from mount source \"/dy_video1/docker-data/volumes/runner-bcvnjjb9-project-11377-concurrent-0-cache-3c3f060a0374fc8bc39395164f415a70/_data\": lstat /dy_video1/docker-data/volumes/runner-bcvnjjb9-project-11377-concurrent-0-cache-3c3f060a0374fc8bc39395164f415a70: no such file or directory (linux_set.go:105:5s) 恢复镜像 通过centos镜像安装cppcheck和cpplint,安装完成后导出镜像，重新导入并修改名称\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ### 下载centos镜像 docker pull centos:7 ### 启动centos容器，进入安装环境cppcheck cpplint docker run -it centos:7 /bin/bash ### 安装基础编译工具 yum install wget yum install gcc yum install gcc-c++ yum install make yum install cmake ### 下载cppcheck源码编译 wget -O cppcheck.tar.gz https://github.com/danmar/cppcheck/archive/refs/tags/2.12.1.tar.gz tar -xvzf cppcheck.tar.gz cd cppcheck-2.12.1 \u0026\u0026 \\ mkdir build \u0026\u0026 \\ cd build \u0026\u0026 \\ cmake .. \u0026\u0026 \\ cmake --build . \u0026\u0026 \\ make install SRCDIR={解压的cppcheck路径}/cppcheck-2.12.1/build CFGDIR={解压的cppcheck路径}/cppcheck-2.12.1/cfg FILESDIR=/usr/bin sudo ln -s /usr/local/bin/cppcheck /usr/bin/cppcheck ## 安装cpplint yum install python3 rm -rf /usr/bin/python sudo ln -s /usr/bin/python3 /usr/bin/python pip3 install cpplint -i https://pypi.tuna.tsinghua.edu.cn/simple ### 退出容器 exit ### 容器导出 docker export centos \u003e container.tar ### tar导入为镜像命名为10.1.107.12:5000/dy/cppcheck docker import container.tar 10.1.107.12:5000/dy/cppcheck Gitlab-Runner 注册 在下载centos镜像操作中，走了很多弯路，最大的弯路是设置docker代理，提高docker pull速度，由于误操作，导致GitLab-Runner镜像丢失\ndocker运行Gitlab-Runner 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ### 下载gitlab-runner 镜像，alpine小一点 docker pull gitlab/gitlab-runner:alpine ### 使用本地系统卷挂载，启动 Runner 容器 docker run -d --name gitlab-runner --restart always -v /srv/gitlab-runner/config:/etc/gitlab-runner -v /var/run/docker.sock:/var/run/docker.sock gitlab/gitlab-runner:alpine ### 进入容器执行注册 docker exec -it gitlab-runner bash ### 重新注册,git地址和REGISTRATION_TOKEN 在gitlab设置Settings CI/CD中查看 sudo gitlab-runner register --url https://XXXX/ --registration-token $REGISTRATION_TOKEN \u003e Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com ) ###直接回车 \u003e Please enter the gitlab-ci token for this runner #### 直接回车 \u003e Please enter the gitlab-ci description for this runner ### 随意写个描述 \u003e Please enter the gitlab-ci tags for this runner (comma separated): ### 定义个tag，我用的 ai-bus1 \u003e Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell: docker \u003e Please enter the Docker image (eg. ruby:2.1): alpine:latest ### 退出容器 exit 再次报错 勾选Indicates whether this runner can pick jobs without tags project拉取新分支测试,测试报错 1 2 3 4 5 6 7 8 9 10 11 WARNING: Failed to pull image with policy \"always\": Error response from daemon: Get \"http://10.1.107.12:5000/v2/\": dial tcp 10.1.107.12:5000: connect: connection refused (manager.go:237:0s) ERROR: Job failed: failed to pull image \"10.1.107.12:5000/dy/cppcheck\" with specified policies [always]: Error response from daemon: Get \"http://10.1.107.12:5000/v2/\": dial tcp 10.1.107.12:5000: connect: connection refused (manager.go:237:0s) 预计是docker运行gitlab-runner未绑定端口导致，查看.gitlab-ci.yml文件中image字段是10.1.107.12:5000/dy/cppcheck,我采用解决方案是修改镜像名 #### 修改gitlab-ci.yml文件中image字段 image:codecheck:v1 #### 删除10.1.107.12:5000/dy/cppcheck 镜像 docker rmi 10.1.107.12:5000/dy/cppcheck #### 导入container.tar命名为codecheck:v1 docker import container.tar codecheck:v1 继续报错 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 WARNING: Failed to pull image with policy \"always\": Error response from daemon: pull access denied for codecheck, repository does not exist or may require 'docker login': denied: requested access to the resource is denied (manager.go:237:2s) ERROR: Job failed: failed to pull image \"codecheck:v1\" with specified policies [always]: Error response from daemon: pull access denied for codecheck, repository does not exist or may require 'docker login': denied: requested access to the resource is denied (manager.go:237:2s) ### 修改宿主机中gitlab-runner配置 vim /etc/gitlab-runner/config.toml ### 增加pull_policy = \"never\" #### 修改容器中gitlab-runner配置 docker exec -it gitlab-runner bash vim /etc/gitlab-runner/config.toml ### 增加pull_policy = \"never\" #### 修改参考 [[runners]] name = \"XXXX\" url = \"https://gitlab.com/\" id = 412 token = \"XXXX\" token_obtained_at = 2023-10-19T02:08:04Z token_expires_at = 0001-01-01T00:00:00Z executor = \"docker\" [runners.custom_build_dir] [runners.cache] [runners.cache.s3] [runners.cache.gcs] [runners.cache.azure] [runners.docker] tls_verify = false image = \"alpine:latest\" privileged = false disable_entrypoint_overwrite = false oom_kill_disable = false disable_cache = false volumes = [\"/cache\"] shm_size = 0 pull_policy = \"never\" ### pull_policy参数作用 pull_policy = “never” ### 只能使用 Runner 所在的 Docker 主机上提取过的本地镜像 pull_policy = “if-not-present” ### Runner 将首先检查映像是否在本地存在。如果是，则使用图像的本地版本 pull_policy = “always” ### 默认拉取策略 (未设置 pull_policy 执行默认拉取策略)，去拉取公网上的镜像 再次测试，测试通过，问题修复\n后续 写完本文后，下班回到家洗澡时，思考这个问题的原因，因运行以前注册的runner提示的错误，与倒数第二个错误类似，怀疑本次问题修复，主要原因是镜像的缺失和运行未绑定端口导致。关闭gitlab-runner docker 容器和gitlab中ai-bus1 runner，重新测试测试运行无误，说明只重新安装cpplint/cppcheck镜像和修改image字段镜像名，即可修复此问题。\n参考资料 搭建一个自己的 Gitlab CI Runner 在容器中运行极狐GitLab Runner 注册 Runner Docker-从入门到实践-导出和导入 ","description":"","tags":["gitlab","cppcheck","cpplint","CI","docker"],"title":"解决存储迁移导致的Gitlab Runner问题","uri":"/posts/gitlab_runner/"},{"categories":["技术"],"content":"背景 看到一篇文章零成本搭建现代博客之搭建篇，目前采用的博客方案存在以下不足：\n目前我博客基于infinity搭建，空间只有5G，时间久了空间不足 域名续费，一年成本100+，每年换一个域名太麻烦 安装 安装和本地预览博客，参考Hugo官方文档 quick-start 我选择的LoveIt主题，下载完成后将blog/themes/LoveIt/exampleSite/config.toml 中的内容覆盖blog/hugo.toml文件中的内容 创建blog/static/images目录存放图片，直接相对路径即可使用本地图片,例如：\"/images/avatar.jpeg\" 主题配置 重点介绍我修改的地方 主题目录地址 博客标题、博客副标题 博客logo 主页显示头像 关掉社交 hugo.toml完整配置如下，可自行对比 baseURL = \"https://xiaoshame.github.io/\"\r# theme\r# 主题\rtheme = \"LoveIt\"\r# themes directory\r# 主题目录\rthemesDir = \"themes\"\r# website title\r# 网站标题\rtitle = \"阿松日常\"\r# determines default content language [\"en\", \"zh-cn\", \"fr\", \"pl\", ...]\r# 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...]\rdefaultContentLanguage = \"zh-cn\"\r# language code [\"en\", \"zh-CN\", \"fr\", \"pl\", ...]\r# 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...]\rlanguageCode = \"zh-CN\"\r# language name [\"English\", \"简体中文\", \"Français\", \"Polski\", ...]\r# 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...]\rlanguageName = \"简体中文\"\r# whether to include Chinese/Japanese/Korean\r# 是否包括中日韩文字\rhasCJKLanguage = true\rsummaryLength = 200\r# default amount of posts in each pages\r# 默认每页列表显示的文章数目\rpaginate = 10\r# copyright description used only for seo schema\r# 版权描述，仅仅用于 SEO\rcopyright = \"CC BY-NC 4.0\"\r# whether to use robots.txt\r# 是否使用 robots.txt\renableRobotsTXT = true\r# whether to use git commit log\r# 是否使用 git 信息\renableGitInfo = true\r# whether to use emoji code\r# 是否使用 emoji 代码\renableEmoji = true\r# ignore some build errors\r# 忽略一些构建错误\rignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"]\r# Author config\r# 作者配置\r[author]\rname = \"阿松日常\"\remail = \"xiaoshame1209@gmail.com\"\rlink = \"\"\r[params]\r# site default theme [\"auto\", \"light\", \"dark\"]\r# 网站默认主题 [\"auto\", \"light\", \"dark\"]\rdefaultTheme = \"light\"\r# public git repo url only then enableGitInfo is true\r# 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效\rgitRepo = \"https://github.com/xiaoshame/xiaoshame.github.io.git\"\r# which hash function used for SRI, when empty, no SRI is used\r# [\"sha256\", \"sha384\", \"sha512\", \"md5\"]\r# 哪种哈希函数用来 SRI, 为空时表示不使用 SRI\r# [\"sha256\", \"sha384\", \"sha512\", \"md5\"]\rfingerprint = \"\"\r# date format\r# 日期格式\rdateFormat = \"2006-01-02\"\r# website title for Open Graph and Twitter Cards\r# 网站标题, 用于 Open Graph 和 Twitter Cards\rtitle = \"阿松日常\"\r# website description for RSS, SEO, Open Graph and Twitter Cards\r# 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards\rdescription = \"阿松日常的个人博客，奶爸一枚，分享效率提升技巧和带娃日常\"\r# website images for Open Graph and Twitter Cards\r# 网站图片, 用于 Open Graph 和 Twitter Cards\rimages = \"/images/logo.png\"\r# Header config\r# 页面头部导航栏配置\r[params.header]\r# desktop header mode [\"fixed\", \"normal\", \"auto\"]\r# 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"]\rdesktopMode = \"fixed\"\r# mobile header mode [\"fixed\", \"normal\", \"auto\"]\r# 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"]\rmobileMode = \"auto\"\r# Header title config\r# 页面头部导航栏标题配置\r[params.header.title]\r# URL of the LOGO\r# LOGO 的 URL\rlogo = \"/images/logo.png\"\r# title name\r# 标题名称\rname = \"阿松日常\"\r# you can add extra information before the name (HTML format is supported), such as icons\r# 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标\rpre = \"\"\r# you can add extra information after the name (HTML format is supported), such as icons\r# 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标\rpost = \"\"\r# whether to use typeit animation for title name\r# 是否为标题显示打字机动画\rtypeit = false\r# Footer config\r# 页面底部信息配置\r[params.footer]\renable = true\r# Custom content (HTML format is supported)\r# 自定义内容 (支持 HTML 格式)\rcustom = \"\"\r# whether to show Hugo and theme info\r# 是否显示 Hugo 和主题信息\rhugo = false\r# whether to show copyright info\r# 是否显示版权信息\rcopyright = true\r# whether to show the author\r# 是否显示作者\rauthor = true\r# site creation time\r# 网站创立年份\rsince = 2023\r# ICP info only in China (HTML format is supported)\r# ICP 备案信息，仅在中国使用 (支持 HTML 格式)\ricp = \"\"\r# license info (HTML format is supported)\r# 许可协议信息 (支持 HTML 格式)\rlicense= '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e'\r# Section (all posts) page config\r# Section (所有文章) 页面配置\r[params.section]\r# special amount of posts in each section page\r# section 页面每页显示文章数量\rpaginate = 20\r# date format (month and day)\r# 日期格式 (月和日)\rdateFormat = \"01-02\"\r# amount of RSS pages\r# RSS 文章数目\rrss = 10\r# List (category or tag) page config\r# List (目录或标签) 页面配置\r[params.list]\r# special amount of posts in each list page\r# list 页面每页显示文章数量\rpaginate = 20\r# date format (month and day)\r# 日期格式 (月和日)\rdateFormat = \"01-02\"\r# amount of RSS pages\r# RSS 文章数目\rrss = 10\r# App icon config\r# 应用图标配置\r[params.app]\r# optional site title override for the app when added to an iOS home screen or Android launcher\r# 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题\rtitle = \"阿松日常\"\r# whether to omit favicon resource links\r# 是否隐藏网站图标资源链接\rnoFavicon = false\r# modern SVG favicon to use in place of older style .png and .ico files\r# 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件\rsvgFavicon = \"/images/logo.svg\"\r# Android browser theme color\r# Android 浏览器主题色\rthemeColor = \"#ffffff\"\r# Safari mask icon color\r# Safari 图标颜色\riconColor = \"#5bbad5\"\r# Windows v8-11 tile color\r# Windows v8-11 磁贴颜色\rtileColor = \"#da532c\"\r# Search config\r# 搜索配置\r[params.search]\renable = true\r# type of search engine [\"lunr\", \"algolia\"]\r# 搜索引擎的类型 [\"lunr\", \"algolia\"]\rtype = \"algolia\"\r# max index length of the chunked content\r# 文章内容最长索引长度\rcontentLength = 4000\r# placeholder of the search bar\r# 搜索框的占位提示语\rplaceholder = \"\"\r# max number of results length\r# 最大结果数目\rmaxResultLength = 10\r# snippet length of the result\r# 结果内容片段长度\rsnippetLength = 30\r# HTML tag name of the highlight part in results\r# 搜索结果中高亮部分的 HTML 标签\rhighlightTag = \"em\"\r# whether to use the absolute URL based on the baseURL in search index\r# 是否在搜索索引中使用基于 baseURL 的绝对路径\rabsoluteURL = false\r[params.search.algolia]\rindex = \"\"\rappID = \"\"\rsearchKey = \"\"\r# Page global config\r# 文章页面全局配置\r[params.page]\r# whether to hide a page from home page\r# 是否在主页隐藏一篇文章\rhiddenFromHomePage = false\r# whether to hide a page from search results\r# 是否在搜索结果中隐藏一篇文章\rhiddenFromSearch = false\r# whether to enable twemoji\r# 是否使用 twemoji\rtwemoji = false\r# whether to enable lightgallery\r# 是否使用 lightgallery\rlightgallery = true\r# whether to enable the ruby extended syntax\r# 是否使用 ruby 扩展语法\rruby = true\r# whether to enable the fraction extended syntax\r# 是否使用 fraction 扩展语法\rfraction = true\r# whether to enable the fontawesome extended syntax\r# 是否使用 fontawesome 扩展语法\rfontawesome = true\r# whether to show link to Raw Markdown content of the content\r# 是否显示原始 Markdown 文档内容的链接\rlinkToMarkdown = false\r# whether to show the full text content in RSS\r# 是否在 RSS 中显示全文内容\rrssFullText = false\r# Table of the contents config\r# 目录配置\r[params.page.toc]\r# whether to enable the table of the contents\r# 是否使用目录\renable = true\r# whether to keep the static table of the contents in front of the post\r# 是否保持使用文章前面的静态目录\rkeepStatic = false\r# whether to make the table of the contents in the sidebar automatically collapsed\r# 是否使侧边目录自动折叠展开\rauto = true\r# Code config\r# 代码配置\r[params.page.code]\r# whether to show the copy button of the code block\r# 是否显示代码块的复制按钮\rcopy = true\r# the maximum number of lines of displayed code by default\r# 默认展开显示的代码行数\rmaxShownLines = 200\r# KaTeX mathematical formulas config (KaTeX https://katex.org/)\r# KaTeX 数学公式配置 (KaTeX https://katex.org/)\r[params.page.math]\renable = false\r# default inline delimiter is $ ... $ and \\( ... \\)\r# 默认行内定界符是 $ ... $ 和 \\( ... \\)\rinlineLeftDelimiter = \"\"\rinlineRightDelimiter = \"\"\r# default block delimiter is $$ ... $$, \\[ ... \\], \\begin{equation} ... \\end{equation} and some other functions\r# 默认块定界符是 $$ ... $$, \\[ ... \\], \\begin{equation} ... \\end{equation} 和一些其它的函数\rblockLeftDelimiter = \"\"\rblockRightDelimiter = \"\"\r# KaTeX extension copy_tex\r# KaTeX 插件 copy_tex\rcopyTex = true\r# KaTeX extension mhchem\r# KaTeX 插件 mhchem\rmhchem = true\r# Mapbox GL JS config (Mapbox GL JS https://docs.mapbox.com/mapbox-gl-js)\r# Mapbox GL JS 配置 (Mapbox GL JS https://docs.mapbox.com/mapbox-gl-js)\r[params.page.mapbox]\r# access token of Mapbox GL JS\r# Mapbox GL JS 的 access token\raccessToken = \"pk.eyJ1IjoiZGlsbG9uenEiLCJhIjoiY2s2czd2M2x3MDA0NjNmcGxmcjVrZmc2cyJ9.aSjv2BNuZUfARvxRYjSVZQ\"\r# style for the light theme\r# 浅色主题的地图样式\rlightStyle = \"mapbox://styles/mapbox/light-v10?optimize=true\"\r# style for the dark theme\r# 深色主题的地图样式\rdarkStyle = \"mapbox://styles/mapbox/dark-v10?optimize=true\"\r# whether to add NavigationControl (https://docs.mapbox.com/mapbox-gl-js/api/#navigationcontrol)\r# 是否添加 NavigationControl (https://docs.mapbox.com/mapbox-gl-js/api/#navigationcontrol)\rnavigation = true\r# whether to add GeolocateControl (https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol)\r# 是否添加 GeolocateControl (https://docs.mapbox.com/mapbox-gl-js/api/#geolocatecontrol)\rgeolocate = true\r# whether to add ScaleControl (https://docs.mapbox.com/mapbox-gl-js/api/#scalecontrol)\r# 是否添加 ScaleControl (https://docs.mapbox.com/mapbox-gl-js/api/#scalecontrol)\rscale = true\r# whether to add FullscreenControl (https://docs.mapbox.com/mapbox-gl-js/api/#fullscreencontrol)\r# 是否添加 FullscreenControl (https://docs.mapbox.com/mapbox-gl-js/api/#fullscreencontrol)\rfullscreen = true\r# Social share links in post page\r# 文章页面的分享信息设置\r[params.page.share]\renable = false\rTwitter = true\rFacebook = true\rHackerNews = true\rReddit = true\rLine = true\r# Comment config\r# 评论系统设置\r[params.page.comment]\renable = true\r# giscus comment config (https://giscus.app/)\r# giscus comment 评论系统设置 (https://giscus.app/zh-CN)\r[params.page.comment.giscus]\r# You can refer to the official documentation of giscus to use the following configuration.\r# 你可以参考官方文档来使用下列配置\renable = true\rrepo = \"xiaoshame/xiaoshame.github.io\"\rrepoId = \"**\"\rcategory = \"Announcements\"\rcategoryId = \"**\"\r# automatically adapt the current theme i18n configuration when empty\r# 为空时自动适配当前主题 i18n 配置\rlang = \"\"\rmapping = \"pathname\"\rreactionsEnabled = \"1\"\remitMetadata = \"0\"\rinputPosition = \"bottom\"\rlazyLoading = false\rlightTheme = \"light\"\rdarkTheme = \"dark\"\r# Third-party library config\r# 第三方库配置\r[params.page.library]\r[params.page.library.css]\r# someCSS = \"some.css\"\r# located in \"assets/\" 位于 \"assets/\"\r# Or 或者\r# someCSS = \"https://cdn.example.com/some.css\"\r[params.page.library.js]\r# someJavascript = \"some.js\"\r# located in \"assets/\" 位于 \"assets/\"\r# Or 或者\r# someJavascript = \"https://cdn.example.com/some.js\"\r# Page SEO config\r# 页面 SEO 配置\r[params.page.seo]\r# image URL\r# 图片 URL\rimages = [\"/images/logo.png\"]\r# Publisher info\r# 出版者信息\r[params.page.seo.publisher]\rname = \"阿松日常\"\rlogoUrl = \"/images/avatar.png\"\r# TypeIt config\r# TypeIt 配置\r[params.typeit]\r# typing speed between each step (measured in milliseconds)\r# 每一步的打字速度 (单位是毫秒)\rspeed = 100\r# blinking speed of the cursor (measured in milliseconds)\r# 光标的闪烁速度 (单位是毫秒)\rcursorSpeed = 1000\r# character used for the cursor (HTML format is supported)\r# 光标的字符 (支持 HTML 格式)\rcursorChar = \"|\"\r# cursor duration after typing finishing (measured in milliseconds, \"-1\" means unlimited)\r# 打字结束之后光标的持续时间 (单位是毫秒, \"-1\" 代表无限大)\rduration = -1\r# Site verification code for Google/Bing/Yandex/Pinterest/Baidu\r# 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu\r[params.verification]\rgoogle = \"*\"\rbing = \"\"\ryandex = \"\"\rpinterest = \"\"\rbaidu = \"\"\r# Site SEO config\r# 网站 SEO 配置\r[params.seo]\r# image URL\r# 图片 URL\rimage = \"/images/logo.png\"\r# thumbnail URL\r# 缩略图 URL\rthumbnailUrl = \"/images/logo.png\"\r# Analytics config\r# 网站分析配置\r[params.analytics]\renable = true\r# Google Analytics\r[params.analytics.google]\rid = \"G-*\"\r# whether to anonymize IP\r# 是否匿名化用户 IP\ranonymizeIP = true\r# Fathom Analytics\r[params.analytics.fathom]\rid = \"\"\r# server url for your tracker if you're self hosting\r# 自行托管追踪器时的主机路径\rserver = \"\"\r# Plausible Analytics\r[params.analytics.plausible]\rdataDomain = \"\"\r# Yandex Metrica\r[params.analytics.yandexMetrica]\rid = \"\"\r# Cookie consent config\r# Cookie 许可配置\r[params.cookieconsent]\renable = false\r# text strings used for Cookie consent banner\r# 用于 Cookie 许可横幅的文本字符串\r[params.cookieconsent.content]\rmessage = \"\"\rdismiss = \"\"\rlink = \"\"\r# CDN config for third-party library files\r# 第三方库文件的 CDN 设置\r[params.cdn]\r# CDN data file name, disabled by default\r# [\"jsdelivr.yml\"]\r# located in \"themes/LoveIt/assets/data/cdn/\" directory\r# you can store your own data files in the same path under your project:\r# \"assets/data/cdn/\"\r# CDN 数据文件名称, 默认不启用\r# [\"jsdelivr.yml\"]\r# 位于 \"themes/LoveIt/assets/data/cdn/\" 目录\r# 可以在你的项目下相同路径存放你自己的数据文件:\r# \"assets/data/cdn/\"\rdata = \"jsdelivr.yml\"\r# Markup related configuration in Hugo\r# Hugo 解析文档的配置\r[markup]\r# Syntax Highlighting (https://gohugo.io/content-management/syntax-highlighting)\r# 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting)\r[markup.highlight]\rcodeFences = true\rguessSyntax = true\rlineNos = true\rlineNumbersInTable = true\r# false is a necessary configuration (https://github.com/dillonzq/LoveIt/issues/158)\r# false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158)\rnoClasses = false\r# Goldmark is from Hugo 0.60 the default library used for Markdown\r# Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库\r[markup.goldmark]\r[markup.goldmark.extensions]\rdefinitionList = true\rfootnote = true\rlinkify = true\rstrikethrough = true\rtable = true\rtaskList = true\rtypographer = true\r[markup.goldmark.renderer]\r# whether to use HTML tags directly in the document\r# 是否在文档中直接使用 HTML 标签\runsafe = true\r# Table Of Contents settings\r# 目录设置\r[markup.tableOfContents]\rstartLevel = 2\rendLevel = 6\r# Sitemap config\r# 网站地图配置\r[sitemap]\rchangefreq = \"weekly\"\rfilename = \"sitemap.xml\"\rpriority = 0.5\r# Permalinks config (https://gohugo.io/content-management/urls/#permalinks)\r# Permalinks 配置 (https://gohugo.io/content-management/urls/#permalinks)\r[Permalinks]\r# posts = \":year/:month/:filename\"\rposts = \":filename\"\r# Options to make output .md files\r# 用于输出 Markdown 格式文档的设置\r[mediaTypes]\r[mediaTypes.\"text/plain\"]\rsuffixes = [\"md\"]\r# Options to make output .md files\r# 用于输出 Markdown 格式文档的设置\r[outputFormats.MarkDown]\rmediaType = \"text/plain\"\risPlainText = true\risHTML = false\r# Options to make hugo output files\r# 用于 Hugo 输出文档的设置\r[outputs]\rhome = [\"HTML\", \"RSS\", \"JSON\"]\rpage = [\"HTML\", \"MarkDown\"]\rsection = [\"HTML\", \"RSS\"]\rtaxonomy = [\"HTML\", \"RSS\"]\r# Multilingual\r# 多语言\r[languages]\r[languages.zh-cn]\rweight = 2\rlanguageCode = \"zh-CN\"\rlanguageName = \"简体中文\"\rhasCJKLanguage = true\rcopyright = \"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\"\r[languages.zh-cn.menu]\r[[languages.zh-cn.menu.main]]\rweight = 1\ridentifier = \"posts\"\rpre = \"\u003ci class='fa-solid fa-book'\u003e\u003c/i\u003e\"\rpost = \"\"\rname = \"所有文章\"\rurl = \"/posts/\"\rtitle = \"\"\r[[languages.zh-cn.menu.main]]\rweight = 2\ridentifier = \"favorites\"\rpre = \"\u003ci class='fa-solid fa-bookmark'\u003e\u003c/i\u003e\"\rpost = \"\"\rname = \"收藏夹\"\rurl = \"/favorites/\"\rtitle = \"\"\r[[languages.zh-cn.menu.main]]\rweight = 3\ridentifier = \"comments\"\rpre = \"\u003ci class='fa-solid fa-comment'\u003e\u003c/i\u003e\"\rpost = \"\"\rname = \"留言板\"\rurl = \"/comments/\"\rtitle = \"\"\r[[languages.zh-cn.menu.main]]\rweight = 4\ridentifier = \"sites\"\rpre = \"\u003ci class='fa-solid fa-link'\u003e\u003c/i\u003e\"\rpost = \"\"\rname = \"友情链接\"\rurl = \"/sites/\"\rtitle = \"\" # 二级菜单\r[[languages.zh-cn.menu.main]]\rparent = \"posts\"\rpre = \"\u003ci class='fas fa-fw fa-th'\u003e\u003c/i\u003e\"\rname = \"分类\"\ridentifier = \"categories\"\rurl = \"/categories/\"\rweight = 1\r[[languages.zh-cn.menu.main]]\rparent = \"posts\"\ridentifier = \"tags\"\rpost = \"\"\rpre = \"\u003ci class='fas fa-fw fa-tag'\u003e\u003c/i\u003e\"\rname = \"标签\"\rurl = \"/tags/\"\rtitle = \"\"\rweight = 2\r[languages.zh-cn.params]\r[languages.zh-cn.params.search]\renable = true\rtype = \"algolia\"\rcontentLength = 4000\rplaceholder = \"\"\rmaxResultLength = 10\rsnippetLength = 50\rhighlightTag = \"em\"\rabsoluteURL = false\r[languages.zh-cn.params.search.algolia]\rindex = \"index.zh-cn\"\rappID = \"PASDMWALPK\"\rsearchKey = \"b42948e51daaa93df92381c8e2ac0f93\"\r[languages.zh-cn.params.home]\rrss = 10\r[languages.zh-cn.params.home.profile]\renable = true\rgravatarEmail = \"xiaoshame1209@gmail.com\"\ravatarURL = \"/images/avatar.png\"\rtitle = \"\"\rsubtitle = \"一位普通的奶爸，一个不出名的程序员，正在努力赚钱和感受生活的酸甜苦辣\"\rtypeit = true\rsocial = true\rdisclaimer = \"\"\r[languages.zh-cn.params.social]\rGitHub = \"https://github.com/xiaoshame/\"\rEmail = \"xiaoshame1209@gmail.com\"\rRSS = true\r[languages.zh-cn.params.home.posts]\renable = true\r# special amount of posts in each home posts page\r# 主页每页显示文章数量\rpaginate = 10 Github部署 参考Hugo官方github部署 官方文档要求将hugo.toml传到git上，其中包含部分key，存在风险 使用hugo生成pubilc文件，上传到仓库\n修改blog/.github/workflows/hugo.yaml文件,核心是屏蔽hugo在远端构建，只对pubilc文件打包\n# Sample workflow for building and deploying a Hugo site to GitHub Pages\rname: Deploy Hugo site to Pages\ron:\r# Runs on pushes targeting the default branch\rpush:\rbranches:\r- master\r# Allows you to run this workflow manually from the Actions tab\rworkflow_dispatch:\r# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages\rpermissions:\rcontents: read\rpages: write\rid-token: write\r# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.\r# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.\rconcurrency:\rgroup: \"pages\"\rcancel-in-progress: false\r# Default to bash\rdefaults:\rrun:\rshell: bash\rjobs:\r# Build job\rbuild:\rruns-on: ubuntu-latest\r# env:\r# HUGO_VERSION: 0.119.0\rsteps:\r# - name: Install Hugo CLI\r# run: |\r# wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\\r# \u0026\u0026 sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass\rrun: sudo snap install dart-sass\r- name: Checkout\ruses: actions/checkout@v3\rwith:\rsubmodules: recursive\rfetch-depth: 0\r- name: Setup Pages\rid: pages\ruses: actions/configure-pages@v3\r- name: Install Node.js dependencies\rrun: \"[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026\u0026 npm ci || true\"\r# - name: Build with Hugo\r# env:\r# # For maximum backward compatibility with Hugo modules\r# HUGO_ENVIRONMENT: production\r# HUGO_ENV: production\r# run: |\r# hugo \\\r# --gc \\\r# --minify \\\r# --baseURL \"${{ steps.pages.outputs.base_url }}/\" - name: Upload artifact\ruses: actions/upload-pages-artifact@v1\rwith:\rpath: ./public\r# Deployment job\rdeploy:\renvironment:\rname: github-pages\rurl: ${{ steps.deployment.outputs.page_url }}\rruns-on: ubuntu-latest\rneeds: build\rsteps:\r- name: Deploy to GitHub Pages\rid: deployment\ruses: actions/deploy-pages@v2 配置Giscus评论 对应项目开启GitHub Discussions github上安装Giscus 利用GitHub GraphQL API获取repoId，categoryId，参考Github 如何获取仓库的 repo_id 和 category_id 修改hugo.toml中repo，repoId，category，categoryId，打开giscus关闭valine，通过enable字段控制，参考安装部分hugo.toml文件 hugo生成相应代码，同步pubilc文件夹到仓库中 收藏页 修改hugo.toml中menu.main配置，添加favorites菜单 生成页面 使用指令 hugo new favorites/index.md，在blog/content目录下生成favorites/index.md文件 在index.md中编辑内容，draft 值调整为fasle，表示不是草稿 hugo生成相应页面代码，同步pubilc文件夹到仓库 封面图 本想给文章加个封面图，在查资料解决过程中，看到一个基于LoveIt魔改主题搭建的博客，文章的样式符合预期，分析自己博客与对方的不同，参考调整\n删除原LoveIt主题，删除blog/theme/LoveIt 文件夹\n删除blog/.git/config中[submodule \"themes/LoveIt\"]的配置\n添加LoveIt主题，git submodule add git@github.com:hakula139/LoveIt.git themes/LoveIt\n下载对方博客内容，将hakula.xyz-main/assets中的内容放到自己博客的blog/assets目录中\n封面图片可以放到文章同级目录中\n修改文章参数设置，参考如下\n---\rtitle : 'Hugo+Github零成本搭建博客流程记录'\rdate : 2023-10-11T10:06:03+08:00\rdraft : false\rtags : [hugo,github,博客]\rcategories : [技术]\rfeaturedImage : /hugo_blog/1697027912506.png\r--- 站点运行时间 通过自定义js实现\nblog/themes/LoveIt/layouts/partials/assets.html 拷贝到blog/layouts/partials/assets.html\nblog/themes/LoveIt/layouts/partials/footer.html 拷贝到blog/layouts/partials/footer.html\n创建blog/static/js/custom.js 文件，粘贴如下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 站点运行时间 */ function runtime() { window.setTimeout(\"runtime()\", 1000); /* 请修改这里的起始时间 */ let startTime = new Date('10/10/2023 15:00:00'); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行`\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e` ' + ((days \u003c 10) ? '0' : '') + days + ' 天 ' + ((hours \u003c 10) ? '0' : '') + hours + ' 时 ' + ((minutes \u003c 10) ? '0' : '') + minutes + ' 分 ' + ((seconds \u003c 10) ? '0' : '') + seconds + ' 秒 '; } runtime(); 修改blog/layouts/partials/assets.html，在最后 {{- partial \"plugin/analytics.html\" . -}}前面加上\n1 2 {{- /* 自定义的js文件 */ -}} \u003cscript type=\"text/javascript\" src=\"/js/custom.js\"\u003e\u003c/script\u003e 修改blog/layouts/partials/footer.html，在 \u003cdivclass=\"footer-container\"\u003e下面加上\n1 2 3 \u003cdiv class=\"footer-line\"\u003e \u003cspan id=\"run-time\"\u003e\u003c/span\u003e \u003c/div\u003e 二级菜单 调整和相关代码完全参考Hugo系列(3.2) - LoveIt主题美化与博客功能增强 · 第三章 二级菜单调整见上面hugo.toml 菜单logo使用fontawesome,在hugo中配置菜单对应pre参数 ","description":"","tags":["hugo","github","建站"],"title":"Hugo+Github零成本搭建博客流程记录","uri":"/posts/hugo_blog/"}]
